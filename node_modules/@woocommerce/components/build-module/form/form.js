/**
 * External dependencies
 */
import { cloneElement, useState, createElement, useCallback, useEffect, forwardRef, useImperativeHandle, } from '@wordpress/element';
import deprecated from '@wordpress/deprecated';
/**
 * Internal dependencies
 */
import { FormContext } from './form-context';
function isChangeEvent(value) {
    return value.target !== undefined;
}
/**
 * A form component to handle form state and provide input helper props.
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function FormComponent({ onSubmit = () => { }, onChange = () => { }, initialValues = {}, ...props }, ref) {
    const [values, setValues] = useState(initialValues);
    const [errors, setErrors] = useState(props.errors || {});
    const [changedFields, setChangedFields] = useState({});
    const [touched, setTouched] = useState(props.touched || {});
    const validate = useCallback((newValues, onValidate = () => { }) => {
        const newErrors = props.validate ? props.validate(newValues) : {};
        setErrors(newErrors || {});
        onValidate();
    }, [props.validate]);
    useEffect(() => {
        validate(values);
    }, []);
    const resetForm = (newInitialValues) => {
        setValues(newInitialValues || {});
        setChangedFields({});
        setTouched({});
        setErrors({});
    };
    useImperativeHandle(ref, () => ({
        resetForm,
    }));
    const isValidForm = async () => {
        await validate(values);
        return !Object.keys(errors).length;
    };
    const setValue = useCallback(
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    (name, value) => {
        setValues({ ...values, [name]: value });
        if (initialValues[name] !== value && !changedFields[name]) {
            setChangedFields({
                ...changedFields,
                [name]: true,
            });
        }
        else if (initialValues[name] === value &&
            changedFields[name]) {
            setChangedFields({
                ...changedFields,
                [name]: false,
            });
        }
        validate({ ...values, [name]: value }, () => {
            const { onChangeCallback } = props;
            // Note that onChange is a no-op by default so this will never be null
            const callback = onChangeCallback || onChange;
            if (onChangeCallback) {
                deprecated('onChangeCallback', {
                    version: '9.0.0',
                    alternative: 'onChange',
                    plugin: '@woocommerce/components',
                });
            }
            // onChange keeps track of validity, so needs to
            // happen after setting the error state.
            if (callback) {
                callback({ name, value }, values, !Object.keys(errors || {}).length);
            }
        });
    }, [values, validate, onChange, props.onChangeCallback]);
    const handleChange = useCallback((name, value) => {
        // Handle native events.
        if (isChangeEvent(value) && value.target) {
            if (value.target.type === 'checkbox') {
                setValue(name, !values[name]);
            }
            else {
                setValue(name, value.target.value);
            }
        }
        else {
            setValue(name, value);
        }
    }, [setValue]);
    const handleBlur = useCallback((name) => {
        setTouched({
            ...touched,
            [name]: true,
        });
    }, [touched]);
    const handleSubmit = async () => {
        const { onSubmitCallback } = props;
        const touchedFields = {};
        Object.keys(values).map((name) => (touchedFields[name] = true));
        setTouched(touchedFields);
        if (await isValidForm()) {
            // Note that onSubmit is a no-op by default so this will never be null
            const callback = onSubmitCallback || onSubmit;
            if (onSubmitCallback) {
                deprecated('onSubmitCallback', {
                    version: '9.0.0',
                    alternative: 'onSubmit',
                    plugin: '@woocommerce/components',
                });
            }
            if (callback) {
                callback(values);
            }
        }
    };
    function getInputProps(name) {
        return {
            value: values[name],
            checked: Boolean(values[name]),
            selected: values[name],
            onChange: (value) => handleChange(name, value),
            onBlur: () => handleBlur(name),
            className: touched[name] && errors[name] ? 'has-error' : undefined,
            help: touched[name] ? errors[name] : null,
        };
    }
    const getStateAndHelpers = () => {
        return {
            values,
            errors,
            touched,
            setTouched,
            setValue,
            handleSubmit,
            getInputProps,
            isValidForm: !Object.keys(errors).length,
        };
    };
    const isDirty = Object.values(changedFields).some(Boolean);
    if (props.children && typeof props.children === 'function') {
        const element = props.children(getStateAndHelpers());
        return (createElement(FormContext.Provider, { value: {
                values,
                errors,
                touched,
                isDirty,
                changedFields,
                setTouched,
                setValue,
                handleSubmit,
                getInputProps,
                isValidForm: !Object.keys(errors).length,
                resetForm,
            } }, cloneElement(element)));
    }
    return (createElement(FormContext.Provider, { value: {
            values,
            errors,
            touched,
            isDirty,
            changedFields,
            setTouched,
            setValue,
            handleSubmit,
            getInputProps,
            isValidForm: !Object.keys(errors).length,
            resetForm,
        } }, props.children));
}
const Form = forwardRef(FormComponent);
export { Form };
