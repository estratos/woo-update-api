"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Form = void 0;
/**
 * External dependencies
 */
const element_1 = require("@wordpress/element");
const deprecated_1 = __importDefault(require("@wordpress/deprecated"));
/**
 * Internal dependencies
 */
const form_context_1 = require("./form-context");
function isChangeEvent(value) {
    return value.target !== undefined;
}
/**
 * A form component to handle form state and provide input helper props.
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function FormComponent(_a, ref) {
    var { onSubmit = () => { }, onChange = () => { }, initialValues = {} } = _a, props = __rest(_a, ["onSubmit", "onChange", "initialValues"]);
    const [values, setValues] = (0, element_1.useState)(initialValues);
    const [errors, setErrors] = (0, element_1.useState)(props.errors || {});
    const [changedFields, setChangedFields] = (0, element_1.useState)({});
    const [touched, setTouched] = (0, element_1.useState)(props.touched || {});
    const validate = (0, element_1.useCallback)((newValues, onValidate = () => { }) => {
        const newErrors = props.validate ? props.validate(newValues) : {};
        setErrors(newErrors || {});
        onValidate();
    }, [props.validate]);
    (0, element_1.useEffect)(() => {
        validate(values);
    }, []);
    const resetForm = (newInitialValues) => {
        setValues(newInitialValues || {});
        setChangedFields({});
        setTouched({});
        setErrors({});
    };
    (0, element_1.useImperativeHandle)(ref, () => ({
        resetForm,
    }));
    const isValidForm = () => __awaiter(this, void 0, void 0, function* () {
        yield validate(values);
        return !Object.keys(errors).length;
    });
    const setValue = (0, element_1.useCallback)(
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    (name, value) => {
        setValues(Object.assign(Object.assign({}, values), { [name]: value }));
        if (initialValues[name] !== value && !changedFields[name]) {
            setChangedFields(Object.assign(Object.assign({}, changedFields), { [name]: true }));
        }
        else if (initialValues[name] === value &&
            changedFields[name]) {
            setChangedFields(Object.assign(Object.assign({}, changedFields), { [name]: false }));
        }
        validate(Object.assign(Object.assign({}, values), { [name]: value }), () => {
            const { onChangeCallback } = props;
            // Note that onChange is a no-op by default so this will never be null
            const callback = onChangeCallback || onChange;
            if (onChangeCallback) {
                (0, deprecated_1.default)('onChangeCallback', {
                    version: '9.0.0',
                    alternative: 'onChange',
                    plugin: '@woocommerce/components',
                });
            }
            // onChange keeps track of validity, so needs to
            // happen after setting the error state.
            if (callback) {
                callback({ name, value }, values, !Object.keys(errors || {}).length);
            }
        });
    }, [values, validate, onChange, props.onChangeCallback]);
    const handleChange = (0, element_1.useCallback)((name, value) => {
        // Handle native events.
        if (isChangeEvent(value) && value.target) {
            if (value.target.type === 'checkbox') {
                setValue(name, !values[name]);
            }
            else {
                setValue(name, value.target.value);
            }
        }
        else {
            setValue(name, value);
        }
    }, [setValue]);
    const handleBlur = (0, element_1.useCallback)((name) => {
        setTouched(Object.assign(Object.assign({}, touched), { [name]: true }));
    }, [touched]);
    const handleSubmit = () => __awaiter(this, void 0, void 0, function* () {
        const { onSubmitCallback } = props;
        const touchedFields = {};
        Object.keys(values).map((name) => (touchedFields[name] = true));
        setTouched(touchedFields);
        if (yield isValidForm()) {
            // Note that onSubmit is a no-op by default so this will never be null
            const callback = onSubmitCallback || onSubmit;
            if (onSubmitCallback) {
                (0, deprecated_1.default)('onSubmitCallback', {
                    version: '9.0.0',
                    alternative: 'onSubmit',
                    plugin: '@woocommerce/components',
                });
            }
            if (callback) {
                callback(values);
            }
        }
    });
    function getInputProps(name) {
        return {
            value: values[name],
            checked: Boolean(values[name]),
            selected: values[name],
            onChange: (value) => handleChange(name, value),
            onBlur: () => handleBlur(name),
            className: touched[name] && errors[name] ? 'has-error' : undefined,
            help: touched[name] ? errors[name] : null,
        };
    }
    const getStateAndHelpers = () => {
        return {
            values,
            errors,
            touched,
            setTouched,
            setValue,
            handleSubmit,
            getInputProps,
            isValidForm: !Object.keys(errors).length,
        };
    };
    const isDirty = Object.values(changedFields).some(Boolean);
    if (props.children && typeof props.children === 'function') {
        const element = props.children(getStateAndHelpers());
        return ((0, element_1.createElement)(form_context_1.FormContext.Provider, { value: {
                values,
                errors,
                touched,
                isDirty,
                changedFields,
                setTouched,
                setValue,
                handleSubmit,
                getInputProps,
                isValidForm: !Object.keys(errors).length,
                resetForm,
            } }, (0, element_1.cloneElement)(element)));
    }
    return ((0, element_1.createElement)(form_context_1.FormContext.Provider, { value: {
            values,
            errors,
            touched,
            isDirty,
            changedFields,
            setTouched,
            setValue,
            handleSubmit,
            getInputProps,
            isValidForm: !Object.keys(errors).length,
            resetForm,
        } }, props.children));
}
const Form = (0, element_1.forwardRef)(FormComponent);
exports.Form = Form;
