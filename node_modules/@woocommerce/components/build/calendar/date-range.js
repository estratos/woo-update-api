"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * External dependencies
 */
require("core-js/features/object/assign");
require("core-js/features/array/from");
const i18n_1 = require("@wordpress/i18n");
const classnames_1 = __importDefault(require("classnames"));
const element_1 = require("@wordpress/element");
const react_dates_1 = require("react-dates");
const moment_1 = __importDefault(require("moment"));
const lodash_1 = require("lodash");
const prop_types_1 = __importDefault(require("prop-types"));
const viewport_1 = require("@wordpress/viewport");
const date_1 = require("@woocommerce/date");
require("react-dates/initialize");
// ^^ The above: Turn on react-dates classes/styles, see https://github.com/airbnb/react-dates#initialize.
/**
 * Internal dependencies
 */
const input_1 = __importDefault(require("./input"));
const phrases_1 = __importDefault(require("./phrases"));
const isRTL = () => document.documentElement.dir === 'rtl';
// Blur event sources
const CONTAINER_DIV = 'container';
const NEXT_MONTH_CLICK = 'onNextMonthClick';
const PREV_MONTH_CLICK = 'onPrevMonthClick';
/**
 * This is wrapper for a [react-dates](https://github.com/airbnb/react-dates) powered calendar.
 */
class DateRange extends element_1.Component {
    constructor(props) {
        super(props);
        this.onDatesChange = this.onDatesChange.bind(this);
        this.onFocusChange = this.onFocusChange.bind(this);
        this.onInputChange = this.onInputChange.bind(this);
        this.nodeRef = (0, element_1.createRef)();
        this.keepFocusInside = this.keepFocusInside.bind(this);
    }
    /*
     * Todo: We should remove this function when possible.
     * It is kept because focus is lost when we click on the previous and next
     * month buttons or clicking on a date in the calendar.
     * This focus loss closes the date picker popover.
     * Ideally we should add an upstream commit on react-dates to fix this issue.
     *
     * See: https://github.com/WordPress/gutenberg/pull/17201.
     */
    keepFocusInside(blurSource, e) {
        if (!this.nodeRef.current) {
            return;
        }
        const { losesFocusTo } = this.props;
        // Blur triggered internal to the DayPicker component.
        if (CONTAINER_DIV === blurSource &&
            e.target &&
            (e.target.classList.contains('DayPickerNavigation_button') ||
                e.target.classList.contains('CalendarDay')) &&
            // Allow other DayPicker elements to take focus.
            (!e.relatedTarget ||
                (!e.relatedTarget.classList.contains('DayPickerNavigation_button') &&
                    !e.relatedTarget.classList.contains('CalendarDay')))) {
            // Allow other DayPicker elements to take focus.
            if (e.relatedTarget &&
                (e.relatedTarget.classList.contains('DayPickerNavigation_button') ||
                    e.relatedTarget.classList.contains('CalendarDay'))) {
                return;
            }
            // Allow elements inside a specified ref to take focus.
            if (e.relatedTarget &&
                losesFocusTo &&
                losesFocusTo.contains(e.relatedTarget)) {
                return;
            }
            // DayPickerNavigation or CalendarDay mouseUp() is blurring,
            // so switch focus to the DayPicker's focus region.
            const focusRegion = this.nodeRef.current.querySelector('.DayPicker_focusRegion');
            if (focusRegion) {
                focusRegion.focus();
            }
            return;
        }
        // Blur triggered after next/prev click callback props.
        if (PREV_MONTH_CLICK === blurSource ||
            NEXT_MONTH_CLICK === blurSource) {
            // DayPicker's updateStateAfterMonthTransition() is about to blur
            // the activeElement, so focus a DayPickerNavigation button so the next
            // blur event gets fixed by the above logic path.
            const focusRegion = this.nodeRef.current.querySelector('.DayPickerNavigation_button');
            if (focusRegion) {
                focusRegion.focus();
            }
        }
    }
    onDatesChange({ startDate, endDate }) {
        const { onUpdate, shortDateFormat } = this.props;
        onUpdate({
            after: startDate,
            before: endDate,
            afterText: startDate ? startDate.format(shortDateFormat) : '',
            beforeText: endDate ? endDate.format(shortDateFormat) : '',
            afterError: null,
            beforeError: null,
        });
    }
    onFocusChange(focusedInput) {
        this.props.onUpdate({
            focusedInput: !focusedInput ? 'startDate' : focusedInput,
        });
    }
    onInputChange(input, event) {
        const value = event.target.value;
        const { after, before, shortDateFormat } = this.props;
        const { date, error } = (0, date_1.validateDateInputForRange)(input, value, before, after, shortDateFormat);
        this.props.onUpdate({
            [input]: date,
            [input + 'Text']: value,
            [input + 'Error']: value.length > 0 ? error : null,
        });
    }
    setTnitialVisibleMonth(isDoubleCalendar, before) {
        return () => {
            const visibleDate = before || (0, moment_1.default)();
            if (isDoubleCalendar) {
                return visibleDate.clone().subtract(1, 'month');
            }
            return visibleDate;
        };
    }
    render() {
        const { after, before, focusedInput, afterText, beforeText, afterError, beforeError, shortDateFormat, isViewportMobile, isViewportSmall, isInvalidDate, } = this.props;
        const isDoubleCalendar = isViewportMobile && !isViewportSmall;
        return ((0, element_1.createElement)("div", { className: (0, classnames_1.default)('woocommerce-calendar', {
                'is-mobile': isViewportMobile,
            }) },
            (0, element_1.createElement)("div", { className: "woocommerce-calendar__inputs" },
                (0, element_1.createElement)(input_1.default, { value: afterText, onChange: (0, lodash_1.partial)(this.onInputChange, 'after'), dateFormat: shortDateFormat, label: (0, i18n_1.__)('Start Date', 'woocommerce'), error: afterError, describedBy: (0, i18n_1.sprintf)((0, i18n_1.__)("Date input describing a selected date range's start date in format %s", 'woocommerce'), shortDateFormat), onFocus: () => this.onFocusChange('startDate') }),
                (0, element_1.createElement)("div", { className: "woocommerce-calendar__inputs-to" }, (0, i18n_1.__)('to', 'woocommerce')),
                (0, element_1.createElement)(input_1.default, { value: beforeText, onChange: (0, lodash_1.partial)(this.onInputChange, 'before'), dateFormat: shortDateFormat, label: (0, i18n_1.__)('End Date', 'woocommerce'), error: beforeError, describedBy: (0, i18n_1.sprintf)((0, i18n_1.__)("Date input describing a selected date range's end date in format %s", 'woocommerce'), shortDateFormat), onFocus: () => this.onFocusChange('endDate') })),
            (0, element_1.createElement)("div", { className: "woocommerce-calendar__react-dates", ref: this.nodeRef, onBlur: (0, lodash_1.partial)(this.keepFocusInside, CONTAINER_DIV), tabIndex: -1 },
                (0, element_1.createElement)(react_dates_1.DayPickerRangeController, { onNextMonthClick: (0, lodash_1.partial)(this.keepFocusInside, NEXT_MONTH_CLICK), onPrevMonthClick: (0, lodash_1.partial)(this.keepFocusInside, PREV_MONTH_CLICK), onDatesChange: this.onDatesChange, onFocusChange: this.onFocusChange, focusedInput: focusedInput, startDate: after, endDate: before, orientation: 'horizontal', numberOfMonths: isDoubleCalendar ? 2 : 1, isOutsideRange: (date) => {
                        return (isInvalidDate && isInvalidDate(date.toDate()));
                    }, minimumNights: 0, hideKeyboardShortcutsPanel: true, noBorder: true, isRTL: isRTL(), initialVisibleMonth: this.setTnitialVisibleMonth(isDoubleCalendar, before), phrases: phrases_1.default }))));
    }
}
DateRange.propTypes = {
    /**
     * A moment date object representing the selected start. `null` for no selection.
     */
    after: prop_types_1.default.object,
    /**
     * A string error message, shown to the user.
     */
    afterError: prop_types_1.default.string,
    /**
     * The start date in human-readable format. Displayed in the text input.
     */
    afterText: prop_types_1.default.string,
    /**
     * A moment date object representing the selected end. `null` for no selection.
     */
    before: prop_types_1.default.object,
    /**
     * A string error message, shown to the user.
     */
    beforeError: prop_types_1.default.string,
    /**
     * The end date in human-readable format. Displayed in the text input.
     */
    beforeText: prop_types_1.default.string,
    /**
     * String identifying which is the currently focused input (start or end).
     */
    focusedInput: prop_types_1.default.string,
    /**
     * A function to determine if a day on the calendar is not valid
     */
    isInvalidDate: prop_types_1.default.func,
    /**
     * A function called upon selection of a date.
     */
    onUpdate: prop_types_1.default.func.isRequired,
    /**
     * The date format in moment.js-style tokens.
     */
    shortDateFormat: prop_types_1.default.string.isRequired,
    /**
     * A ref that the DateRange can lose focus to.
     * See: https://github.com/woocommerce/woocommerce-admin/pull/2929.
     */
    // eslint-disable-next-line no-undef
    losesFocusTo: prop_types_1.default.instanceOf(Element),
};
exports.default = (0, viewport_1.withViewportMatch)({
    isViewportMobile: '< medium',
    isViewportSmall: '< small',
})(DateRange);
