"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * External dependencies
 */
const element_1 = require("@wordpress/element");
const interpolate_components_1 = __importDefault(require("@automattic/interpolate-components"));
const components_1 = require("@wordpress/components");
const lodash_1 = require("lodash");
const classnames_1 = __importDefault(require("classnames"));
const i18n_1 = require("@wordpress/i18n");
const date_1 = require("@woocommerce/date");
const moment_1 = __importDefault(require("moment"));
/**
 * Internal dependencies
 */
const date_picker_1 = __importDefault(require("../calendar/date-picker"));
const utils_1 = require("./utils");
const dateStringFormat = (0, i18n_1.__)('MMM D, YYYY', 'woocommerce');
const dateFormat = (0, i18n_1.__)('MM/DD/YYYY', 'woocommerce');
class DateFilter extends element_1.Component {
    constructor({ filter }) {
        super(...arguments);
        const [isoAfter, isoBefore] = Array.isArray(filter.value)
            ? filter.value
            : [null, filter.value];
        const after = isoAfter ? (0, date_1.toMoment)(date_1.isoDateFormat, isoAfter) : null;
        const before = isoBefore ? (0, date_1.toMoment)(date_1.isoDateFormat, isoBefore) : null;
        this.state = {
            before,
            beforeText: before ? before.format(dateFormat) : '',
            beforeError: null,
            after,
            afterText: after ? after.format(dateFormat) : '',
            afterError: null,
            rule: filter.rule,
        };
        this.onSingleDateChange = this.onSingleDateChange.bind(this);
        this.onRangeDateChange = this.onRangeDateChange.bind(this);
        this.onRuleChange = this.onRuleChange.bind(this);
    }
    getBetweenString() {
        return (0, i18n_1._x)('{{after /}}{{span}} and {{/span}}{{before /}}', 'Date range inputs arranged on a single line', 'woocommerce');
    }
    getScreenReaderText(filterRule, config) {
        const rule = (0, lodash_1.find)(config.rules, { value: filterRule }) || {};
        const { before, after } = this.state;
        // Return nothing if we're missing input(s)
        if (!before || (rule.value === 'between' && !after)) {
            return '';
        }
        let filterStr = before.format(dateStringFormat);
        if (rule.value === 'between') {
            filterStr = (0, interpolate_components_1.default)({
                mixedString: this.getBetweenString(),
                components: {
                    after: ((0, element_1.createElement)(element_1.Fragment, null, after.format(dateStringFormat))),
                    before: ((0, element_1.createElement)(element_1.Fragment, null, before.format(dateStringFormat))),
                    span: (0, element_1.createElement)(element_1.Fragment, null),
                },
            });
        }
        return (0, utils_1.textContent)((0, interpolate_components_1.default)({
            mixedString: config.labels.title,
            components: {
                filter: (0, element_1.createElement)(element_1.Fragment, null, filterStr),
                rule: (0, element_1.createElement)(element_1.Fragment, null, rule.label),
                title: (0, element_1.createElement)(element_1.Fragment, null),
            },
        }));
    }
    onSingleDateChange({ date, text, error }) {
        const { onFilterChange } = this.props;
        this.setState({ before: date, beforeText: text, beforeError: error });
        if (date) {
            onFilterChange({
                property: 'value',
                value: date.format(date_1.isoDateFormat),
            });
        }
    }
    onRangeDateChange(input, { date, text, error }) {
        const { onFilterChange } = this.props;
        this.setState({
            [input]: date,
            [input + 'Text']: text,
            [input + 'Error']: error,
        });
        if (date) {
            const { before, after } = this.state;
            let nextAfter = null;
            let nextBefore = null;
            if (input === 'after') {
                nextAfter = date.format(date_1.isoDateFormat);
                nextBefore = before ? before.format(date_1.isoDateFormat) : null;
            }
            if (input === 'before') {
                nextAfter = after ? after.format(date_1.isoDateFormat) : null;
                nextBefore = date.format(date_1.isoDateFormat);
            }
            if (nextAfter && nextBefore) {
                onFilterChange({
                    property: 'value',
                    value: [nextAfter, nextBefore],
                });
            }
        }
    }
    onRuleChange(newRule) {
        const { onFilterChange } = this.props;
        const { rule } = this.state;
        let newDateState = null;
        let shouldResetValue = false;
        if ([rule, newRule].includes('between')) {
            newDateState = {
                before: null,
                beforeText: '',
                beforeError: null,
                after: null,
                afterText: '',
                afterError: null,
            };
            shouldResetValue = true;
        }
        this.setState(Object.assign({ rule: newRule }, newDateState));
        onFilterChange({
            property: 'rule',
            value: newRule,
            shouldResetValue,
        });
    }
    isFutureDate(dateString) {
        return (0, moment_1.default)().isBefore((0, moment_1.default)(dateString), 'day');
    }
    getFormControl({ date, error, onUpdate, text }) {
        return ((0, element_1.createElement)(date_picker_1.default, { date: date, dateFormat: dateFormat, error: error, isInvalidDate: this.isFutureDate, onUpdate: onUpdate, text: text }));
    }
    getRangeInput() {
        const { before, beforeText, beforeError, after, afterText, afterError, } = this.state;
        return (0, interpolate_components_1.default)({
            mixedString: this.getBetweenString(),
            components: {
                after: this.getFormControl({
                    date: after,
                    error: afterError,
                    onUpdate: (0, lodash_1.partial)(this.onRangeDateChange, 'after'),
                    text: afterText,
                }),
                before: this.getFormControl({
                    date: before,
                    error: beforeError,
                    onUpdate: (0, lodash_1.partial)(this.onRangeDateChange, 'before'),
                    text: beforeText,
                }),
                span: (0, element_1.createElement)("span", { className: "separator" }),
            },
        });
    }
    getFilterInputs() {
        const { before, beforeText, beforeError, rule } = this.state;
        if (rule === 'between') {
            return this.getRangeInput();
        }
        return this.getFormControl({
            date: before,
            error: beforeError,
            onUpdate: this.onSingleDateChange,
            text: beforeText,
        });
    }
    render() {
        const { className, config, isEnglish } = this.props;
        const { rule } = this.state;
        const { labels, rules } = config;
        const screenReaderText = this.getScreenReaderText(rule, config);
        const children = (0, interpolate_components_1.default)({
            mixedString: labels.title,
            components: {
                title: (0, element_1.createElement)("span", { className: className }),
                rule: ((0, element_1.createElement)(components_1.SelectControl, { className: (0, classnames_1.default)(className, 'woocommerce-filters-advanced__rule'), options: rules, value: rule, onChange: this.onRuleChange, "aria-label": labels.rule })),
                filter: ((0, element_1.createElement)("div", { className: (0, classnames_1.default)(className, 'woocommerce-filters-advanced__input-range', {
                        'is-between': rule === 'between',
                    }) }, this.getFilterInputs())),
            },
        });
        /*eslint-disable jsx-a11y/no-noninteractive-tabindex*/
        return ((0, element_1.createElement)("fieldset", { className: "woocommerce-filters-advanced__line-item", tabIndex: "0" },
            (0, element_1.createElement)("legend", { className: "screen-reader-text" }, labels.add || ''),
            (0, element_1.createElement)("div", { className: (0, classnames_1.default)('woocommerce-filters-advanced__fieldset', {
                    'is-english': isEnglish,
                }) }, children),
            screenReaderText && ((0, element_1.createElement)("span", { className: "screen-reader-text" }, screenReaderText))));
        /*eslint-enable jsx-a11y/no-noninteractive-tabindex*/
    }
}
exports.default = DateFilter;
