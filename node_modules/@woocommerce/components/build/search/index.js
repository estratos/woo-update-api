"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Search = void 0;
/**
 * External dependencies
 */
const element_1 = require("@wordpress/element");
const lodash_1 = require("lodash");
const prop_types_1 = __importDefault(require("prop-types"));
const classnames_1 = __importDefault(require("classnames"));
/**
 * Internal dependencies
 */
const select_control_1 = __importDefault(require("../select-control"));
const autocompleters_1 = require("./autocompleters");
/**
 * A search box which autocompletes results while typing, allowing for the user to select an existing object
 * (product, order, customer, etc). Currently only products are supported.
 */
class Search extends element_1.Component {
    constructor(props) {
        super(props);
        this.state = {
            options: [],
        };
        this.appendFreeTextSearch = this.appendFreeTextSearch.bind(this);
        this.fetchOptions = this.fetchOptions.bind(this);
        this.updateSelected = this.updateSelected.bind(this);
    }
    getAutocompleter() {
        switch (this.props.type) {
            case 'attributes':
                return autocompleters_1.attributes;
            case 'categories':
                return autocompleters_1.productCategory;
            case 'countries':
                return autocompleters_1.countries;
            case 'coupons':
                return autocompleters_1.coupons;
            case 'customers':
                return autocompleters_1.customers;
            case 'downloadIps':
                return autocompleters_1.downloadIps;
            case 'emails':
                return autocompleters_1.emails;
            case 'orders':
                return autocompleters_1.orders;
            case 'products':
                return autocompleters_1.product;
            case 'taxes':
                return autocompleters_1.taxes;
            case 'usernames':
                return autocompleters_1.usernames;
            case 'variableProducts':
                return autocompleters_1.variableProduct;
            case 'variations':
                return autocompleters_1.variations;
            case 'custom':
                if (!this.props.autocompleter ||
                    typeof this.props.autocompleter !== 'object') {
                    throw new Error("Invalid autocompleter provided to Search component, it requires a completer object when using 'custom' type.");
                }
                return this.props.autocompleter;
            default:
                return {};
        }
    }
    getFormattedOptions(options, query) {
        const autocompleter = this.getAutocompleter();
        const formattedOptions = [];
        options.forEach((option) => {
            const formattedOption = {
                key: autocompleter.getOptionIdentifier(option),
                label: autocompleter.getOptionLabel(option, query),
                keywords: autocompleter
                    .getOptionKeywords(option)
                    .filter(Boolean),
                value: option,
            };
            formattedOptions.push(formattedOption);
        });
        return formattedOptions;
    }
    fetchOptions(previousOptions, query) {
        if (!query) {
            return [];
        }
        const autocompleterOptions = this.getAutocompleter().options;
        // Support arrays, sync- & async functions that returns an array.
        const resolvedOptions = Promise.resolve(typeof autocompleterOptions === 'function'
            ? autocompleterOptions(query)
            : autocompleterOptions || []);
        return resolvedOptions.then((response) => __awaiter(this, void 0, void 0, function* () {
            const options = this.getFormattedOptions(response, query);
            this.setState({ options });
            return options;
        }));
    }
    updateSelected(selected) {
        const { onChange } = this.props;
        const autocompleter = this.getAutocompleter();
        const formattedSelections = selected.map((option) => {
            return option.value
                ? autocompleter.getOptionCompletion(option.value)
                : option;
        });
        onChange(formattedSelections);
    }
    appendFreeTextSearch(options, query) {
        const { allowFreeTextSearch } = this.props;
        if (!query || !query.length) {
            return [];
        }
        if (!allowFreeTextSearch) {
            return options;
        }
        const autocompleter = this.getAutocompleter();
        return [...autocompleter.getFreeTextOptions(query), ...options];
    }
    render() {
        const autocompleter = this.getAutocompleter();
        const { className, inlineTags, placeholder, selected, showClearButton, staticResults, disabled, multiple, } = this.props;
        const { options } = this.state;
        const inputType = autocompleter.inputType
            ? autocompleter.inputType
            : 'text';
        return ((0, element_1.createElement)("div", null,
            (0, element_1.createElement)(select_control_1.default, { className: (0, classnames_1.default)('woocommerce-search', className, {
                    'is-static-results': staticResults,
                }), disabled: disabled, hideBeforeSearch: true, inlineTags: inlineTags, isSearchable: true, getSearchExpression: autocompleter.getSearchExpression, multiple: multiple, placeholder: placeholder, onChange: this.updateSelected, onFilter: this.appendFreeTextSearch, onSearch: this.fetchOptions, options: options, searchDebounceTime: 500, searchInputType: inputType, selected: selected, showClearButton: showClearButton })));
    }
}
exports.Search = Search;
Search.propTypes = {
    /**
     * Render additional options in the autocompleter to allow free text entering depending on the type.
     */
    allowFreeTextSearch: prop_types_1.default.bool,
    /**
     * Class name applied to parent div.
     */
    className: prop_types_1.default.string,
    /**
     * Function called when selected results change, passed result list.
     */
    onChange: prop_types_1.default.func,
    /**
     * The object type to be used in searching.
     */
    type: prop_types_1.default.oneOf([
        'attributes',
        'categories',
        'countries',
        'coupons',
        'customers',
        'downloadIps',
        'emails',
        'orders',
        'products',
        'taxes',
        'usernames',
        'variableProducts',
        'variations',
        'custom',
    ]).isRequired,
    /**
     * The custom autocompleter to be used in searching when type is 'custom'
     */
    autocompleter: prop_types_1.default.object,
    /**
     * A placeholder for the search input.
     */
    placeholder: prop_types_1.default.string,
    /**
     * An array of objects describing selected values or optionally a string for a single value.
     * If the label of the selected value is omitted, the Tag of that value will not
     * be rendered inside the search box.
     */
    selected: prop_types_1.default.oneOfType([
        prop_types_1.default.string,
        prop_types_1.default.arrayOf(prop_types_1.default.shape({
            key: prop_types_1.default.oneOfType([
                prop_types_1.default.number,
                prop_types_1.default.string,
            ]).isRequired,
            label: prop_types_1.default.string,
        })),
    ]),
    /**
     * Render tags inside input, otherwise render below input.
     */
    inlineTags: prop_types_1.default.bool,
    /**
     * Render a 'Clear' button next to the input box to remove its contents.
     */
    showClearButton: prop_types_1.default.bool,
    /**
     * Render results list positioned statically instead of absolutely.
     */
    staticResults: prop_types_1.default.bool,
    /**
     * Whether the control is disabled or not.
     */
    disabled: prop_types_1.default.bool,
};
Search.defaultProps = {
    allowFreeTextSearch: false,
    onChange: lodash_1.noop,
    selected: [],
    inlineTags: false,
    showClearButton: false,
    staticResults: false,
    disabled: false,
    multiple: true,
};
exports.default = Search;
