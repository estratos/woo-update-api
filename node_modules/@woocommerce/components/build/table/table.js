"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * External dependencies
 */
const i18n_1 = require("@wordpress/i18n");
const element_1 = require("@wordpress/element");
const classnames_1 = __importDefault(require("classnames"));
const components_1 = require("@wordpress/components");
const lodash_1 = require("lodash");
const prop_types_1 = __importDefault(require("prop-types"));
const compose_1 = require("@wordpress/compose");
const icons_1 = require("@wordpress/icons");
const ASC = 'asc';
const DESC = 'desc';
const getDisplay = (cell) => cell.display || null;
/**
 * A table component, without the Card wrapper. This is a basic table display, sortable, but no default filtering.
 *
 * Row data should be passed to the component as a list of arrays, where each array is a row in the table.
 * Headers are passed in separately as an array of objects with column-related properties. For example,
 * this data would render the following table.
 *
 * ```js
 * const headers = [ { label: 'Month' }, { label: 'Orders' }, { label: 'Revenue' } ];
 * const rows = [
 * 	[
 * 		{ display: 'January', value: 1 },
 * 		{ display: 10, value: 10 },
 * 		{ display: '$530.00', value: 530 },
 * 	],
 * 	[
 * 		{ display: 'February', value: 2 },
 * 		{ display: 13, value: 13 },
 * 		{ display: '$675.00', value: 675 },
 * 	],
 * 	[
 * 		{ display: 'March', value: 3 },
 * 		{ display: 9, value: 9 },
 * 		{ display: '$460.00', value: 460 },
 * 	],
 * ]
 * ```
 *
 * |   Month  | Orders | Revenue |
 * | ---------|--------|---------|
 * | January  |     10 | $530.00 |
 * | February |     13 | $675.00 |
 * | March    |      9 | $460.00 |
 */
class Table extends element_1.Component {
    constructor(props) {
        super(props);
        this.state = {
            tabIndex: null,
            isScrollableRight: false,
            isScrollableLeft: false,
        };
        this.container = (0, element_1.createRef)();
        this.sortBy = this.sortBy.bind(this);
        this.updateTableShadow = this.updateTableShadow.bind(this);
        this.getRowKey = this.getRowKey.bind(this);
    }
    componentDidMount() {
        const { scrollWidth, clientWidth } = this.container.current;
        const scrollable = scrollWidth > clientWidth;
        /* eslint-disable react/no-did-mount-set-state */
        this.setState({
            tabIndex: scrollable ? '0' : null,
        });
        /* eslint-enable react/no-did-mount-set-state */
        this.updateTableShadow();
        window.addEventListener('resize', this.updateTableShadow);
    }
    componentDidUpdate() {
        this.updateTableShadow();
    }
    componentWillUnmount() {
        window.removeEventListener('resize', this.updateTableShadow);
    }
    sortBy(key) {
        const { headers, query } = this.props;
        return () => {
            const currentKey = query.orderby ||
                (0, lodash_1.get)((0, lodash_1.find)(headers, { defaultSort: true }), 'key', false);
            const currentDir = query.order ||
                (0, lodash_1.get)((0, lodash_1.find)(headers, { key: currentKey }), 'defaultOrder', DESC);
            let dir = DESC;
            if (key === currentKey) {
                dir = DESC === currentDir ? ASC : DESC;
            }
            this.props.onSort(key, dir);
        };
    }
    updateTableShadow() {
        const table = this.container.current;
        const { isScrollableRight, isScrollableLeft } = this.state;
        const scrolledToEnd = table.scrollWidth - table.scrollLeft <= table.offsetWidth;
        if (scrolledToEnd && isScrollableRight) {
            this.setState({ isScrollableRight: false });
        }
        else if (!scrolledToEnd && !this.state.isScrollableRight) {
            this.setState({ isScrollableRight: true });
        }
        const scrolledToStart = table.scrollLeft <= 0;
        if (scrolledToStart && isScrollableLeft) {
            this.setState({ isScrollableLeft: false });
        }
        else if (!scrolledToStart && !isScrollableLeft) {
            this.setState({ isScrollableLeft: true });
        }
    }
    getRowKey(row, index) {
        if (this.props.rowKey && typeof this.props.rowKey === 'function') {
            return this.props.rowKey(row, index);
        }
        return index;
    }
    render() {
        const { ariaHidden, caption, classNames, headers, instanceId, query, rowHeader, rows, } = this.props;
        const { isScrollableRight, isScrollableLeft, tabIndex } = this.state;
        const classes = (0, classnames_1.default)('woocommerce-table__table', classNames, {
            'is-scrollable-right': isScrollableRight,
            'is-scrollable-left': isScrollableLeft,
        });
        const sortedBy = query.orderby ||
            (0, lodash_1.get)((0, lodash_1.find)(headers, { defaultSort: true }), 'key', false);
        const sortDir = query.order ||
            (0, lodash_1.get)((0, lodash_1.find)(headers, { key: sortedBy }), 'defaultOrder', DESC);
        const hasData = !!rows.length;
        return ((0, element_1.createElement)("div", { className: classes, ref: this.container, tabIndex: tabIndex, "aria-hidden": ariaHidden, "aria-labelledby": `caption-${instanceId}`, role: "group", onScroll: this.updateTableShadow },
            (0, element_1.createElement)("table", null,
                (0, element_1.createElement)("caption", { id: `caption-${instanceId}`, className: "woocommerce-table__caption screen-reader-text" },
                    caption,
                    tabIndex === '0' && ((0, element_1.createElement)("small", null, (0, i18n_1.__)('(scroll to see more)', 'woocommerce')))),
                (0, element_1.createElement)("tbody", null,
                    (0, element_1.createElement)("tr", null, headers.map((header, i) => {
                        const { cellClassName, isLeftAligned, isSortable, isNumeric, key, label, screenReaderLabel, } = header;
                        const labelId = `header-${instanceId}-${i}`;
                        const thProps = {
                            className: (0, classnames_1.default)('woocommerce-table__header', cellClassName, {
                                'is-left-aligned': isLeftAligned || !isNumeric,
                                'is-sortable': isSortable,
                                'is-sorted': sortedBy === key,
                                'is-numeric': isNumeric,
                            }),
                        };
                        if (isSortable) {
                            thProps['aria-sort'] = 'none';
                            if (sortedBy === key) {
                                thProps['aria-sort'] =
                                    sortDir === ASC
                                        ? 'ascending'
                                        : 'descending';
                            }
                        }
                        // We only sort by ascending if the col is already sorted descending
                        const iconLabel = sortedBy === key && sortDir !== ASC
                            ? (0, i18n_1.sprintf)((0, i18n_1.__)('Sort by %s in ascending order', 'woocommerce'), screenReaderLabel || label)
                            : (0, i18n_1.sprintf)((0, i18n_1.__)('Sort by %s in descending order', 'woocommerce'), screenReaderLabel || label);
                        const textLabel = ((0, element_1.createElement)(element_1.Fragment, null,
                            (0, element_1.createElement)("span", { "aria-hidden": Boolean(screenReaderLabel) }, label),
                            screenReaderLabel && ((0, element_1.createElement)("span", { className: "screen-reader-text" }, screenReaderLabel))));
                        return ((0, element_1.createElement)("th", Object.assign({ role: "columnheader", scope: "col", key: header.key || i }, thProps), isSortable ? ((0, element_1.createElement)(element_1.Fragment, null,
                            (0, element_1.createElement)(components_1.Button, { "aria-describedby": labelId, onClick: hasData
                                    ? this.sortBy(key)
                                    : lodash_1.noop },
                                sortedBy === key &&
                                    sortDir === ASC ? ((0, element_1.createElement)(icons_1.Icon, { icon: icons_1.chevronUp })) : ((0, element_1.createElement)(icons_1.Icon, { icon: icons_1.chevronDown })),
                                textLabel),
                            (0, element_1.createElement)("span", { className: "screen-reader-text", id: labelId }, iconLabel))) : (textLabel)));
                    })),
                    hasData ? (rows.map((row, i) => ((0, element_1.createElement)("tr", { key: this.getRowKey(row, i) }, row.map((cell, j) => {
                        const { cellClassName, isLeftAligned, isNumeric, } = headers[j];
                        const isHeader = rowHeader === j;
                        const Cell = isHeader ? 'th' : 'td';
                        const cellClasses = (0, classnames_1.default)('woocommerce-table__item', cellClassName, {
                            'is-left-aligned': isLeftAligned ||
                                !isNumeric,
                            'is-numeric': isNumeric,
                            'is-sorted': sortedBy ===
                                headers[j].key,
                        });
                        const cellKey = this.getRowKey(row, i).toString() + j;
                        return ((0, element_1.createElement)(Cell, { scope: isHeader ? 'row' : null, key: cellKey, className: cellClasses }, getDisplay(cell)));
                    }))))) : ((0, element_1.createElement)("tr", null,
                        (0, element_1.createElement)("td", { className: "woocommerce-table__empty-item", colSpan: headers.length }, (0, i18n_1.__)('No data to display', 'woocommerce'))))))));
    }
}
Table.propTypes = {
    /**
     * Controls whether this component is hidden from screen readers. Used by the loading state, before there is data to read.
     * Don't use this on real tables unless the table data is loaded elsewhere on the page.
     */
    ariaHidden: prop_types_1.default.bool,
    /**
     * A label for the content in this table
     */
    caption: prop_types_1.default.string.isRequired,
    /**
     * Additional CSS classes.
     */
    className: prop_types_1.default.string,
    /**
     * An array of column headers, as objects.
     */
    headers: prop_types_1.default.arrayOf(prop_types_1.default.shape({
        /**
         * Boolean, true if this column is the default for sorting. Only one column should have this set.
         */
        defaultSort: prop_types_1.default.bool,
        /**
         * String, asc|desc if this column is the default for sorting. Only one column should have this set.
         */
        defaultOrder: prop_types_1.default.string,
        /**
         * Boolean, true if this column should be aligned to the left.
         */
        isLeftAligned: prop_types_1.default.bool,
        /**
         * Boolean, true if this column is a number value.
         */
        isNumeric: prop_types_1.default.bool,
        /**
         * Boolean, true if this column is sortable.
         */
        isSortable: prop_types_1.default.bool,
        /**
         * The API parameter name for this column, passed to `orderby` when sorting via API.
         */
        key: prop_types_1.default.string,
        /**
         * The display label for this column.
         */
        label: prop_types_1.default.node,
        /**
         * Boolean, true if this column should always display in the table (not shown in toggle-able list).
         */
        required: prop_types_1.default.bool,
        /**
         * The label used for screen readers for this column.
         */
        screenReaderLabel: prop_types_1.default.string,
    })),
    /**
     * A function called when sortable table headers are clicked, gets the `header.key` as argument.
     */
    onSort: prop_types_1.default.func,
    /**
     * The query string represented in object form
     */
    query: prop_types_1.default.object,
    /**
     * An array of arrays of display/value object pairs.
     */
    rows: prop_types_1.default.arrayOf(prop_types_1.default.arrayOf(prop_types_1.default.shape({
        /**
         * Display value, used for rendering- strings or elements are best here.
         */
        display: prop_types_1.default.node,
        /**
         * "Real" value used for sorting, and should be a string or number. A column with `false` value will not be sortable.
         */
        value: prop_types_1.default.oneOfType([
            prop_types_1.default.string,
            prop_types_1.default.number,
            prop_types_1.default.bool,
        ]),
    }))).isRequired,
    /**
     * Which column should be the row header, defaults to the first item (`0`) (but could be set to `1`, if the first col
     * is checkboxes, for example). Set to false to disable row headers.
     */
    rowHeader: prop_types_1.default.oneOfType([prop_types_1.default.number, prop_types_1.default.bool]),
    /**
     * The rowKey used for the key value on each row, a function that returns the key.
     * Defaults to index.
     */
    rowKey: prop_types_1.default.func,
};
Table.defaultProps = {
    ariaHidden: false,
    headers: [],
    onSort: lodash_1.noop,
    query: {},
    rowHeader: 0,
};
exports.default = (0, compose_1.withInstanceId)(Table);
