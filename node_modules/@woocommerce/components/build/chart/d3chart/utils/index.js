"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isDataEmpty = exports.getUniqueDates = exports.getOrderedKeys = exports.getUniqueKeys = exports.getFormatter = void 0;
/**
 * External dependencies
 */
const lodash_1 = require("lodash");
const d3_format_1 = require("d3-format");
const d3_time_format_1 = require("d3-time-format");
/**
 * Allows an overriding formatter or defaults to d3Format or d3TimeFormat
 *
 * @param {string|Function} format    - either a format string for the D3 formatters or an overriding fomatting method
 * @param {Function}        formatter - default d3Format or another formatting method, which accepts the string `format`
 * @return {Function} to be used to format an input given the format and formatter
 */
const getFormatter = (format, formatter = d3_format_1.format) => typeof format === 'function' ? format : formatter(format);
exports.getFormatter = getFormatter;
/**
 * Returns an array of unique keys contained in the data.
 *
 * @param {Array} data - The chart component's `data` prop.
 * @return {Array} Array of unique keys.
 */
const getUniqueKeys = (data) => {
    const keys = new Set(data.reduce((acc, curr) => acc.concat(Object.keys(curr)), []));
    return [...keys].filter((key) => key !== 'date');
};
exports.getUniqueKeys = getUniqueKeys;
/**
 * Describes `getOrderedKeys`
 *
 * @param {Array} data - The chart component's `data` prop.
 * @return {Array} Array of unique category keys ordered by cumulative total value
 */
const getOrderedKeys = (data) => {
    const keys = (0, exports.getUniqueKeys)(data);
    return keys
        .map((key) => ({
        key,
        focus: true,
        total: data.reduce((a, c) => a + c[key].value, 0),
        visible: true,
    }))
        .sort((a, b) => b.total - a.total);
};
exports.getOrderedKeys = getOrderedKeys;
/**
 * Describes `getUniqueDates`
 *
 * @param {Array}  data       - the chart component's `data` prop.
 * @param {string} dateParser - D3 time format
 * @return {Array} an array of unique date values sorted from earliest to latest
 */
const getUniqueDates = (data, dateParser) => {
    const parseDate = (0, d3_time_format_1.utcParse)(dateParser);
    const dates = new Set(data.map((d) => d.date));
    return [...dates].sort((a, b) => parseDate(a) - parseDate(b));
};
exports.getUniqueDates = getUniqueDates;
/**
 * Check whether data is empty.
 *
 * @param {Array}  data      - the chart component's `data` prop.
 * @param {number} baseValue - base value to test data values against.
 * @return {boolean} `false` if there was at least one data value different than
 * the baseValue.
 */
const isDataEmpty = (data, baseValue = 0) => {
    for (let i = 0; i < data.length; i++) {
        for (const [key, item] of Object.entries(data[i])) {
            if (key !== 'date' &&
                !(0, lodash_1.isNil)(item.value) &&
                item.value !== baseValue) {
                return false;
            }
        }
    }
    return true;
};
exports.isDataEmpty = isDataEmpty;
