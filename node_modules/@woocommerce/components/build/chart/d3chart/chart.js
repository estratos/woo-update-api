"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * External dependencies
 */
const element_1 = require("@wordpress/element");
const prop_types_1 = __importDefault(require("prop-types"));
const classnames_1 = __importDefault(require("classnames"));
const d3_time_format_1 = require("d3-time-format");
/**
 * Internal dependencies
 */
const d3base_1 = __importDefault(require("./d3base"));
const index_1 = require("./utils/index");
const scales_1 = require("./utils/scales");
const axis_1 = require("./utils/axis");
const bar_chart_1 = require("./utils/bar-chart");
const line_chart_1 = require("./utils/line-chart");
const color_1 = require("./utils/color");
const tooltip_1 = __importDefault(require("./utils/tooltip"));
const constants_1 = require("../constants");
const isRTL = () => document.documentElement.dir === 'rtl';
/**
 * A simple D3 line and bar chart component for timeseries data in React.
 */
class D3Chart extends element_1.Component {
    constructor(props) {
        super(props);
        this.drawChart = this.drawChart.bind(this);
        this.getParams = this.getParams.bind(this);
        this.tooltipRef = (0, element_1.createRef)();
    }
    getFormatParams() {
        const { screenReaderFormat, xFormat, x2Format, yFormat, yBelow1Format, } = this.props;
        return {
            screenReaderFormat: (0, index_1.getFormatter)(screenReaderFormat, d3_time_format_1.timeFormat),
            xFormat: (0, index_1.getFormatter)(xFormat, d3_time_format_1.timeFormat),
            x2Format: (0, index_1.getFormatter)(x2Format, d3_time_format_1.timeFormat),
            yBelow1Format: (0, index_1.getFormatter)(yBelow1Format),
            yFormat: (0, index_1.getFormatter)(yFormat),
        };
    }
    getScaleParams(uniqueDates) {
        const { data, height, orderedKeys, chartType } = this.props;
        const margin = this.getMargin();
        const adjHeight = height - margin.top - margin.bottom;
        const adjWidth = this.getWidth() - margin.left - margin.right;
        const { upper: yMax, lower: yMin, step } = (0, scales_1.getYScaleLimits)(data);
        const yScale = (0, scales_1.getYScale)(adjHeight, yMin, yMax);
        if (chartType === 'line') {
            return {
                step,
                xScale: (0, scales_1.getXLineScale)(uniqueDates, adjWidth),
                yMax,
                yMin,
                yScale,
            };
        }
        const compact = this.shouldBeCompact();
        const xScale = (0, scales_1.getXScale)(uniqueDates, adjWidth, compact);
        return {
            step,
            xGroupScale: (0, scales_1.getXGroupScale)(orderedKeys, xScale, compact),
            xScale,
            yMax,
            yMin,
            yScale,
        };
    }
    getParams(uniqueDates) {
        const { chartType, colorScheme, data, interval, mode, orderedKeys } = this.props;
        const newOrderedKeys = orderedKeys || (0, index_1.getOrderedKeys)(data);
        const visibleKeys = newOrderedKeys.filter((key) => key.visible);
        const colorKeys = newOrderedKeys.length > constants_1.selectionLimit
            ? visibleKeys
            : newOrderedKeys;
        return {
            getColor: (0, color_1.getColor)(colorKeys, colorScheme),
            interval,
            mode,
            chartType,
            uniqueDates,
            visibleKeys,
        };
    }
    createTooltip(chart, getColorFunction, visibleKeys) {
        const { tooltipLabelFormat, tooltipPosition, tooltipTitle, tooltipValueFormat, } = this.props;
        const tooltip = new tooltip_1.default();
        tooltip.ref = this.tooltipRef.current;
        tooltip.chart = chart;
        tooltip.position = tooltipPosition;
        tooltip.title = tooltipTitle;
        tooltip.labelFormat = (0, index_1.getFormatter)(tooltipLabelFormat, d3_time_format_1.timeFormat);
        tooltip.valueFormat = (0, index_1.getFormatter)(tooltipValueFormat);
        tooltip.visibleKeys = visibleKeys;
        tooltip.getColor = getColorFunction;
        this.tooltip = tooltip;
    }
    drawChart(node) {
        const { data, dateParser, chartType } = this.props;
        const margin = this.getMargin();
        const uniqueDates = (0, index_1.getUniqueDates)(data, dateParser);
        const formats = this.getFormatParams();
        const params = this.getParams(uniqueDates);
        const scales = this.getScaleParams(uniqueDates);
        const g = node
            .attr('id', 'chart')
            .append('g')
            .attr('transform', `translate(${margin.left}, ${margin.top})`);
        this.createTooltip(g.node(), params.getColor, params.visibleKeys);
        (0, axis_1.drawAxis)(g, params, scales, formats, margin, isRTL());
        // eslint-disable-next-line no-unused-expressions
        chartType === 'line' &&
            (0, line_chart_1.drawLines)(g, data, params, scales, formats, this.tooltip);
        // eslint-disable-next-line no-unused-expressions
        chartType === 'bar' &&
            (0, bar_chart_1.drawBars)(g, data, params, scales, formats, this.tooltip);
    }
    shouldBeCompact() {
        const { data, chartType, width } = this.props;
        if (chartType !== 'bar') {
            return false;
        }
        const margin = this.getMargin();
        const widthWithoutMargins = width - margin.left - margin.right;
        const columnsPerDate = data && data.length ? Object.keys(data[0]).length - 1 : 0;
        const minimumWideWidth = data.length * (columnsPerDate + 1);
        return widthWithoutMargins < minimumWideWidth;
    }
    getMargin() {
        const { margin } = this.props;
        if (isRTL()) {
            return {
                bottom: margin.bottom,
                left: margin.right,
                right: margin.left,
                top: margin.top,
            };
        }
        return margin;
    }
    getWidth() {
        const { data, chartType, width } = this.props;
        if (chartType !== 'bar') {
            return width;
        }
        const margin = this.getMargin();
        const columnsPerDate = data && data.length ? Object.keys(data[0]).length - 1 : 0;
        const minimumWidth = this.shouldBeCompact()
            ? data.length * columnsPerDate
            : data.length * (columnsPerDate + 1);
        return Math.max(width, minimumWidth + margin.left + margin.right);
    }
    getEmptyMessage() {
        const { baseValue, data, emptyMessage } = this.props;
        if (emptyMessage && (0, index_1.isDataEmpty)(data, baseValue)) {
            return ((0, element_1.createElement)("div", { className: "d3-chart__empty-message" }, emptyMessage));
        }
    }
    render() {
        const { className, data, height, orderedKeys, chartType } = this.props;
        const computedWidth = this.getWidth();
        return ((0, element_1.createElement)("div", { className: (0, classnames_1.default)('d3-chart__container', className), style: { height } },
            this.getEmptyMessage(),
            (0, element_1.createElement)("div", { className: "d3-chart__tooltip", ref: this.tooltipRef }),
            (0, element_1.createElement)(d3base_1.default, { className: (0, classnames_1.default)(className), data: data, drawChart: this.drawChart, height: height, orderedKeys: orderedKeys, tooltip: this.tooltip, chartType: chartType, width: computedWidth })));
    }
}
D3Chart.propTypes = {
    /**
     * Base chart value. If no data value is different than the baseValue, the
     * `emptyMessage` will be displayed if provided.
     */
    baseValue: prop_types_1.default.number,
    /**
     * Additional CSS classes.
     */
    className: prop_types_1.default.string,
    /**
     * A chromatic color function to be passed down to d3.
     */
    colorScheme: prop_types_1.default.func,
    /**
     * An array of data.
     */
    data: prop_types_1.default.array.isRequired,
    /**
     * Format to parse dates into d3 time format
     */
    dateParser: prop_types_1.default.string.isRequired,
    /**
     * The message to be displayed if there is no data to render. If no message is provided,
     * nothing will be displayed.
     */
    emptyMessage: prop_types_1.default.string,
    /**
     * Height of the `svg`.
     */
    height: prop_types_1.default.number,
    /**
     * Interval specification (hourly, daily, weekly etc.)
     */
    interval: prop_types_1.default.oneOf([
        'hour',
        'day',
        'week',
        'month',
        'quarter',
        'year',
    ]),
    /**
     * Margins for axis and chart padding.
     */
    margin: prop_types_1.default.shape({
        bottom: prop_types_1.default.number,
        left: prop_types_1.default.number,
        right: prop_types_1.default.number,
        top: prop_types_1.default.number,
    }),
    /**
     * `items-comparison` (default) or `time-comparison`, this is used to generate correct
     * ARIA properties.
     */
    mode: prop_types_1.default.oneOf(['item-comparison', 'time-comparison']),
    /**
     * A datetime formatting string or overriding function to format the screen reader labels.
     */
    screenReaderFormat: prop_types_1.default.oneOfType([
        prop_types_1.default.string,
        prop_types_1.default.func,
    ]),
    /**
     * The list of labels for this chart.
     */
    orderedKeys: prop_types_1.default.array,
    /**
     * A datetime formatting string or overriding function to format the tooltip label.
     */
    tooltipLabelFormat: prop_types_1.default.oneOfType([
        prop_types_1.default.string,
        prop_types_1.default.func,
    ]),
    /**
     * A number formatting string or function to format the value displayed in the tooltips.
     */
    tooltipValueFormat: prop_types_1.default.oneOfType([
        prop_types_1.default.string,
        prop_types_1.default.func,
    ]),
    /**
     * The position where to render the tooltip can be `over` the chart or `below` the chart.
     */
    tooltipPosition: prop_types_1.default.oneOf(['below', 'over']),
    /**
     * A string to use as a title for the tooltip. Takes preference over `tooltipFormat`.
     */
    tooltipTitle: prop_types_1.default.string,
    /**
     * Chart type of either `line` or `bar`.
     */
    chartType: prop_types_1.default.oneOf(['bar', 'line']),
    /**
     * Width of the `svg`.
     */
    width: prop_types_1.default.number,
    /**
     * A datetime formatting string or function, passed to d3TimeFormat.
     */
    xFormat: prop_types_1.default.oneOfType([prop_types_1.default.string, prop_types_1.default.func]),
    /**
     * A datetime formatting string or function, passed to d3TimeFormat.
     */
    x2Format: prop_types_1.default.oneOfType([prop_types_1.default.string, prop_types_1.default.func]),
    /**
     * A number formatting string or function for numbers between -1 and 1, passed to d3Format.
     * If missing, `yFormat` will be used.
     */
    yBelow1Format: prop_types_1.default.oneOfType([prop_types_1.default.string, prop_types_1.default.func]),
    /**
     * A number formatting string or function, passed to d3Format.
     */
    yFormat: prop_types_1.default.oneOfType([prop_types_1.default.string, prop_types_1.default.func]),
};
D3Chart.defaultProps = {
    baseValue: 0,
    data: [],
    dateParser: '%Y-%m-%dT%H:%M:%S',
    height: 200,
    margin: {
        bottom: 30,
        left: 40,
        right: 0,
        top: 20,
    },
    mode: 'time-comparison',
    screenReaderFormat: '%B %-d, %Y',
    tooltipPosition: 'over',
    tooltipLabelFormat: '%B %-d, %Y',
    tooltipValueFormat: ',',
    chartType: 'line',
    width: 600,
    xFormat: '%Y-%m-%d',
    x2Format: '',
    yBelow1Format: '.3~f',
    yFormat: '.3~s',
};
exports.default = D3Chart;
