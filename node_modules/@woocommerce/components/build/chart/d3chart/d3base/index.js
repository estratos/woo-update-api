"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * External dependencies
 */
const classnames_1 = __importDefault(require("classnames"));
const prop_types_1 = __importDefault(require("prop-types"));
const element_1 = require("@wordpress/element");
const lodash_1 = require("lodash");
const d3_selection_1 = require("d3-selection");
/**
 * Provides foundation to use D3 within React.
 *
 * React is responsible for determining when a chart should be updated (e.g. whenever data changes or the browser is
 * resized), while D3 is responsible for the actual rendering of the chart (which is performed via DOM operations that
 * happen outside of React's control).
 *
 * This component makes use of new lifecycle methods that come with React 16.3. Thus, while this component (i.e. the
 * container of the chart) is rendered during the 'render phase' the chart itself is only rendered during the 'commit
 * phase' (i.e. in 'componentDidMount' and 'componentDidUpdate' methods).
 */
class D3Base extends element_1.Component {
    constructor(props) {
        super(props);
        this.chartRef = (0, element_1.createRef)();
    }
    componentDidMount() {
        this.drawUpdatedChart();
    }
    shouldComponentUpdate(nextProps) {
        return (this.props.className !== nextProps.className ||
            !(0, lodash_1.isEqual)(this.props.data, nextProps.data) ||
            !(0, lodash_1.isEqual)(this.props.orderedKeys, nextProps.orderedKeys) ||
            this.props.drawChart !== nextProps.drawChart ||
            this.props.height !== nextProps.height ||
            this.props.chartType !== nextProps.chartType ||
            this.props.width !== nextProps.width);
    }
    componentDidUpdate() {
        this.drawUpdatedChart();
    }
    componentWillUnmount() {
        this.deleteChart();
    }
    delayedScroll() {
        const { tooltip } = this.props;
        return (0, lodash_1.throttle)(() => {
            // eslint-disable-next-line no-unused-expressions
            tooltip && tooltip.hide();
        }, 300);
    }
    deleteChart() {
        (0, d3_selection_1.select)(this.chartRef.current).selectAll('svg').remove();
    }
    /**
     * Renders the chart, or triggers a rendering by updating the list of params.
     */
    drawUpdatedChart() {
        const { drawChart } = this.props;
        const svg = this.getContainer();
        drawChart(svg);
    }
    getContainer() {
        const { className, height, width } = this.props;
        this.deleteChart();
        const svg = (0, d3_selection_1.select)(this.chartRef.current)
            .append('svg')
            .attr('viewBox', `0 0 ${width} ${height}`)
            .attr('height', height)
            .attr('width', width)
            .attr('preserveAspectRatio', 'xMidYMid meet');
        if (className) {
            svg.attr('class', `${className}__viewbox`);
        }
        return svg.append('g');
    }
    render() {
        const { className } = this.props;
        return ((0, element_1.createElement)("div", { className: (0, classnames_1.default)('d3-base', className), ref: this.chartRef, onScroll: this.delayedScroll() }));
    }
}
exports.default = D3Base;
D3Base.propTypes = {
    className: prop_types_1.default.string,
    data: prop_types_1.default.array,
    orderedKeys: prop_types_1.default.array,
    tooltip: prop_types_1.default.object,
    chartType: prop_types_1.default.string,
};
