"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * External dependencies
 */
const i18n_1 = require("@wordpress/i18n");
const classnames_1 = __importDefault(require("classnames"));
const element_1 = require("@wordpress/element");
const d3_format_1 = require("d3-format");
const lodash_1 = require("lodash");
const line_graph_1 = __importDefault(require("gridicons/dist/line-graph"));
const stats_alt_1 = __importDefault(require("gridicons/dist/stats-alt"));
const components_1 = require("@wordpress/components");
const d3_scale_chromatic_1 = require("d3-scale-chromatic");
const memoize_one_1 = __importDefault(require("memoize-one"));
const prop_types_1 = __importDefault(require("prop-types"));
const viewport_1 = require("@wordpress/viewport");
const dompurify_1 = require("dompurify");
const navigation_1 = require("@woocommerce/navigation");
/**
 * Internal dependencies
 */
const placeholder_1 = __importDefault(require("./placeholder"));
const section_1 = require("../section");
const d3chart_1 = require("./d3chart");
const index_1 = require("./d3chart/utils/index");
const constants_1 = require("./constants");
function getD3CurrencyFormat(symbol, position) {
    switch (position) {
        case 'left_space':
            return [symbol + ' ', ''];
        case 'right':
            return ['', symbol];
        case 'right_space':
            return ['', ' ' + symbol];
        case 'left':
        default:
            return [symbol, ''];
    }
}
/**
 * A chart container using d3, to display timeseries data with an interactive legend.
 */
class Chart extends element_1.Component {
    constructor(props) {
        super(props);
        this.chartBodyRef = (0, element_1.createRef)();
        const dataKeys = this.getDataKeys();
        this.state = {
            focusedKeys: [],
            visibleKeys: dataKeys.slice(0, constants_1.selectionLimit),
            width: 0,
        };
        this.prevDataKeys = dataKeys.sort();
        this.handleTypeToggle = this.handleTypeToggle.bind(this);
        this.handleLegendToggle = this.handleLegendToggle.bind(this);
        this.handleLegendHover = this.handleLegendHover.bind(this);
        this.updateDimensions = this.updateDimensions.bind(this);
        this.getVisibleData = (0, memoize_one_1.default)(this.getVisibleData);
        this.getOrderedKeys = (0, memoize_one_1.default)(this.getOrderedKeys);
        this.setInterval = this.setInterval.bind(this);
    }
    getDataKeys() {
        const { data, filterParam, mode, query } = this.props;
        if (mode === 'item-comparison') {
            const selectedIds = filterParam
                ? (0, navigation_1.getIdsFromQuery)(query[filterParam])
                : [];
            return this.getOrderedKeys([], [], selectedIds).map((orderedItem) => orderedItem.key);
        }
        return (0, index_1.getUniqueKeys)(data);
    }
    componentDidUpdate() {
        const { data } = this.props;
        if (!data || !data.length) {
            return;
        }
        const uniqueKeys = (0, index_1.getUniqueKeys)(data).sort();
        if (!(0, lodash_1.isEqual)(uniqueKeys, this.prevDataKeys)) {
            const dataKeys = this.getDataKeys();
            this.prevDataKeys = uniqueKeys;
            /* eslint-disable react/no-did-update-set-state */
            this.setState({
                visibleKeys: dataKeys.slice(0, constants_1.selectionLimit),
            });
            /* eslint-enable react/no-did-update-set-state */
        }
    }
    componentDidMount() {
        this.updateDimensions();
        this.setD3DefaultFormat();
        window.addEventListener('resize', this.updateDimensions);
    }
    componentWillUnmount() {
        window.removeEventListener('resize', this.updateDimensions);
    }
    setD3DefaultFormat() {
        const { symbol: currencySymbol, symbolPosition, decimalSeparator: decimal, thousandSeparator: thousands, } = this.props.currency;
        (0, d3_format_1.formatDefaultLocale)({
            decimal,
            thousands,
            grouping: [3],
            currency: getD3CurrencyFormat(currencySymbol, symbolPosition),
        });
    }
    getOrderedKeys(focusedKeys, visibleKeys, selectedIds = []) {
        const { data, legendTotals, mode } = this.props;
        if (!data || data.length === 0) {
            return [];
        }
        const uniqueKeys = data.reduce((accum, curr) => {
            Object.entries(curr).forEach(([key, value]) => {
                if (key !== 'date' && !accum[key]) {
                    accum[key] = value.label;
                }
            });
            return accum;
        }, {});
        const updatedKeys = Object.entries(uniqueKeys).map(([key, label]) => {
            label = (0, dompurify_1.sanitize)(label, { ALLOWED_TAGS: [] });
            return {
                focus: focusedKeys.length === 0 || focusedKeys.includes(key),
                key,
                label,
                total: legendTotals &&
                    typeof legendTotals[key] !== 'undefined'
                    ? legendTotals[key]
                    : data.reduce((a, c) => a + c[key].value, 0),
                visible: visibleKeys.includes(key),
            };
        });
        if (mode === 'item-comparison') {
            return updatedKeys
                .sort((a, b) => b.total - a.total)
                .filter((key) => key.total > 0 ||
                selectedIds.includes(parseInt(key.key, 10)));
        }
        return updatedKeys;
    }
    handleTypeToggle(chartType) {
        if (this.props.chartType !== chartType) {
            const { path, query } = this.props;
            (0, navigation_1.updateQueryString)({ chartType }, path, query);
        }
    }
    handleLegendToggle(event) {
        const { interactiveLegend } = this.props;
        if (!interactiveLegend) {
            return;
        }
        const key = event.currentTarget.id.split('_').pop();
        const { focusedKeys, visibleKeys } = this.state;
        if (visibleKeys.includes(key)) {
            this.setState({
                focusedKeys: (0, lodash_1.without)(focusedKeys, key),
                visibleKeys: (0, lodash_1.without)(visibleKeys, key),
            });
        }
        else {
            this.setState({
                focusedKeys: focusedKeys.concat([key]),
                visibleKeys: visibleKeys.concat([key]),
            });
        }
    }
    handleLegendHover(event) {
        if (event.type === 'mouseleave' || event.type === 'blur') {
            this.setState({
                focusedKeys: [],
            });
        }
        else if (event.type === 'mouseenter' || event.type === 'focus') {
            const key = event.currentTarget.id.split('__').pop();
            this.setState({
                focusedKeys: [key],
            });
        }
    }
    updateDimensions() {
        this.setState({
            width: this.chartBodyRef.current.offsetWidth,
        });
    }
    getVisibleData(data, orderedKeys) {
        const visibleKeys = orderedKeys.filter((d) => d.visible);
        return data.map((d) => {
            const newRow = { date: d.date };
            visibleKeys.forEach((row) => {
                newRow[row.key] = d[row.key];
            });
            return newRow;
        });
    }
    setInterval(interval) {
        const { path, query } = this.props;
        (0, navigation_1.updateQueryString)({ interval }, path, query);
    }
    renderIntervalSelector() {
        const { interval, allowedIntervals } = this.props;
        if (!allowedIntervals || allowedIntervals.length < 1) {
            return null;
        }
        const intervalLabels = {
            hour: (0, i18n_1.__)('By hour', 'woocommerce'),
            day: (0, i18n_1.__)('By day', 'woocommerce'),
            week: (0, i18n_1.__)('By week', 'woocommerce'),
            month: (0, i18n_1.__)('By month', 'woocommerce'),
            quarter: (0, i18n_1.__)('By quarter', 'woocommerce'),
            year: (0, i18n_1.__)('By year', 'woocommerce'),
        };
        return ((0, element_1.createElement)("div", { className: "woocommerce-chart__interval-select" },
            (0, element_1.createElement)(components_1.SelectControl, { value: interval, options: allowedIntervals.map((allowedInterval) => ({
                    value: allowedInterval,
                    label: intervalLabels[allowedInterval],
                })), onChange: this.setInterval })));
    }
    getChartHeight() {
        const { isViewportLarge, isViewportMobile } = this.props;
        if (isViewportMobile) {
            return 180;
        }
        if (isViewportLarge) {
            return 300;
        }
        return 220;
    }
    getLegendPosition() {
        const { legendPosition, mode, isViewportWide } = this.props;
        if (legendPosition) {
            return legendPosition;
        }
        if (isViewportWide && mode === 'time-comparison') {
            return 'top';
        }
        if (isViewportWide && mode === 'item-comparison') {
            return 'side';
        }
        return 'bottom';
    }
    render() {
        const { focusedKeys, visibleKeys, width } = this.state;
        const { baseValue, chartType, data, dateParser, emptyMessage, filterParam, interactiveLegend, interval, isRequesting, isViewportLarge, itemsLabel, mode, query, screenReaderFormat, showHeaderControls, title, tooltipLabelFormat, tooltipValueFormat, tooltipTitle, valueType, xFormat, x2Format, yBelow1Format, yFormat, } = this.props;
        const selectedIds = filterParam
            ? (0, navigation_1.getIdsFromQuery)(query[filterParam])
            : [];
        const orderedKeys = this.getOrderedKeys(focusedKeys, visibleKeys, selectedIds);
        const visibleData = isRequesting
            ? null
            : this.getVisibleData(data, orderedKeys);
        const legendPosition = this.getLegendPosition();
        const legendDirection = legendPosition === 'top' ? 'row' : 'column';
        const chartDirection = legendPosition === 'side' ? 'row' : 'column';
        const chartHeight = this.getChartHeight();
        const legend = legendPosition !== 'hidden' && isRequesting ? null : ((0, element_1.createElement)(d3chart_1.D3Legend, { colorScheme: d3_scale_chromatic_1.interpolateViridis, data: orderedKeys, handleLegendHover: this.handleLegendHover, handleLegendToggle: this.handleLegendToggle, interactive: interactiveLegend, legendDirection: legendDirection, legendValueFormat: tooltipValueFormat, totalLabel: (0, i18n_1.sprintf)(itemsLabel, orderedKeys.length) }));
        const margin = {
            bottom: 50,
            left: 80,
            right: 30,
            top: 0,
        };
        let d3chartYFormat = yFormat;
        let d3chartYBelow1Format = yBelow1Format;
        if (!yFormat) {
            switch (valueType) {
                case 'average':
                    d3chartYFormat = ',.0f';
                    break;
                case 'currency':
                    d3chartYFormat = '$.3~s';
                    d3chartYBelow1Format = '$.3~f';
                    break;
                case 'number':
                    d3chartYFormat = ',.0f';
                    break;
            }
        }
        return ((0, element_1.createElement)("div", { className: "woocommerce-chart" },
            showHeaderControls && ((0, element_1.createElement)("div", { className: "woocommerce-chart__header" },
                (0, element_1.createElement)(section_1.H, { className: "woocommerce-chart__title" }, title),
                legendPosition === 'top' && legend,
                this.renderIntervalSelector(),
                (0, element_1.createElement)(components_1.NavigableMenu, { className: "woocommerce-chart__types", orientation: "horizontal", role: "menubar" },
                    (0, element_1.createElement)(components_1.Button, { className: (0, classnames_1.default)('woocommerce-chart__type-button', {
                            'woocommerce-chart__type-button-selected': chartType === 'line',
                        }), title: (0, i18n_1.__)('Line chart', 'woocommerce'), "aria-checked": chartType === 'line', role: "menuitemradio", tabIndex: chartType === 'line' ? 0 : -1, onClick: (0, lodash_1.partial)(this.handleTypeToggle, 'line') },
                        (0, element_1.createElement)(line_graph_1.default, null)),
                    (0, element_1.createElement)(components_1.Button, { className: (0, classnames_1.default)('woocommerce-chart__type-button', {
                            'woocommerce-chart__type-button-selected': chartType === 'bar',
                        }), title: (0, i18n_1.__)('Bar chart', 'woocommerce'), "aria-checked": chartType === 'bar', role: "menuitemradio", tabIndex: chartType === 'bar' ? 0 : -1, onClick: (0, lodash_1.partial)(this.handleTypeToggle, 'bar') },
                        (0, element_1.createElement)(stats_alt_1.default, null))))),
            (0, element_1.createElement)(section_1.Section, { component: false },
                (0, element_1.createElement)("div", { className: (0, classnames_1.default)('woocommerce-chart__body', `woocommerce-chart__body-${chartDirection}`), ref: this.chartBodyRef },
                    legendPosition === 'side' && legend,
                    isRequesting && ((0, element_1.createElement)(element_1.Fragment, null,
                        (0, element_1.createElement)("span", { className: "screen-reader-text" }, (0, i18n_1.__)('Your requested data is loading', 'woocommerce')),
                        (0, element_1.createElement)(placeholder_1.default, { height: chartHeight }))),
                    !isRequesting && width > 0 && ((0, element_1.createElement)(d3chart_1.D3Chart, { baseValue: baseValue, chartType: chartType, colorScheme: d3_scale_chromatic_1.interpolateViridis, data: visibleData, dateParser: dateParser, height: chartHeight, emptyMessage: emptyMessage, interval: interval, margin: margin, mode: mode, orderedKeys: orderedKeys, screenReaderFormat: screenReaderFormat, tooltipLabelFormat: tooltipLabelFormat, tooltipValueFormat: tooltipValueFormat, tooltipPosition: isViewportLarge ? 'over' : 'below', tooltipTitle: tooltipTitle, valueType: valueType, width: chartDirection === 'row'
                            ? width - 320
                            : width, xFormat: xFormat, x2Format: x2Format, yBelow1Format: d3chartYBelow1Format, yFormat: d3chartYFormat }))),
                legendPosition === 'bottom' && ((0, element_1.createElement)("div", { className: "woocommerce-chart__footer" }, legend)))));
    }
}
Chart.propTypes = {
    /**
     * Allowed intervals to show in a dropdown.
     */
    allowedIntervals: prop_types_1.default.array,
    /**
     * Base chart value. If no data value is different than the baseValue, the
     * `emptyMessage` will be displayed if provided.
     */
    baseValue: prop_types_1.default.number,
    /**
     * Chart type of either `line` or `bar`.
     */
    chartType: prop_types_1.default.oneOf(['bar', 'line']),
    /**
     * An array of data.
     */
    data: prop_types_1.default.array.isRequired,
    /**
     * Format to parse dates into d3 time format
     */
    dateParser: prop_types_1.default.string.isRequired,
    /**
     * The message to be displayed if there is no data to render. If no message is provided,
     * nothing will be displayed.
     */
    emptyMessage: prop_types_1.default.string,
    /**
     * Name of the param used to filter items. If specified, it will be used, in combination
     * with query, to detect which elements are being used by the current filter and must be
     * displayed even if their value is 0.
     */
    filterParam: prop_types_1.default.string,
    /**
     * Label describing the legend items.
     */
    itemsLabel: prop_types_1.default.string,
    /**
     * `item-comparison` (default) or `time-comparison`, this is used to generate correct
     * ARIA properties.
     */
    mode: prop_types_1.default.oneOf(['item-comparison', 'time-comparison']),
    /**
     * Current path
     */
    path: prop_types_1.default.string,
    /**
     * The query string represented in object form
     */
    query: prop_types_1.default.object,
    /**
     * Whether the legend items can be activated/deactivated.
     */
    interactiveLegend: prop_types_1.default.bool,
    /**
     * Interval specification (hourly, daily, weekly etc).
     */
    interval: prop_types_1.default.oneOf([
        'hour',
        'day',
        'week',
        'month',
        'quarter',
        'year',
    ]),
    /**
     * Information about the currently selected interval, and set of allowed intervals for the chart. See `getIntervalsForQuery`.
     */
    intervalData: prop_types_1.default.object,
    /**
     * Render a chart placeholder to signify an in-flight data request.
     */
    isRequesting: prop_types_1.default.bool,
    /**
     * Position the legend must be displayed in. If it's not defined, it's calculated
     * depending on the viewport width and the mode.
     */
    legendPosition: prop_types_1.default.oneOf(['bottom', 'side', 'top', 'hidden']),
    /**
     * Values to overwrite the legend totals. If not defined, the sum of all line values will be used.
     */
    legendTotals: prop_types_1.default.object,
    /**
     * A datetime formatting string or overriding function to format the screen reader labels.
     */
    screenReaderFormat: prop_types_1.default.oneOfType([
        prop_types_1.default.string,
        prop_types_1.default.func,
    ]),
    /**
     * Wether header UI controls must be displayed.
     */
    showHeaderControls: prop_types_1.default.bool,
    /**
     * A title describing this chart.
     */
    title: prop_types_1.default.string,
    /**
     * A datetime formatting string or overriding function to format the tooltip label.
     */
    tooltipLabelFormat: prop_types_1.default.oneOfType([
        prop_types_1.default.string,
        prop_types_1.default.func,
    ]),
    /**
     * A number formatting string or function to format the value displayed in the tooltips.
     */
    tooltipValueFormat: prop_types_1.default.oneOfType([
        prop_types_1.default.string,
        prop_types_1.default.func,
    ]),
    /**
     * A string to use as a title for the tooltip. Takes preference over `tooltipLabelFormat`.
     */
    tooltipTitle: prop_types_1.default.string,
    /**
     * What type of data is to be displayed? Number, Average, String?
     */
    valueType: prop_types_1.default.string,
    /**
     * A datetime formatting string, passed to d3TimeFormat.
     */
    xFormat: prop_types_1.default.string,
    /**
     * A datetime formatting string, passed to d3TimeFormat.
     */
    x2Format: prop_types_1.default.string,
    /**
     * A number formatting string, passed to d3Format.
     */
    yBelow1Format: prop_types_1.default.string,
    /**
     * A number formatting string, passed to d3Format.
     */
    yFormat: prop_types_1.default.string,
    /**
     * A currency object passed to d3Format.
     */
    currency: prop_types_1.default.object,
};
Chart.defaultProps = {
    baseValue: 0,
    chartType: 'line',
    data: [],
    dateParser: '%Y-%m-%dT%H:%M:%S',
    interactiveLegend: true,
    interval: 'day',
    isRequesting: false,
    mode: 'time-comparison',
    screenReaderFormat: '%B %-d, %Y',
    showHeaderControls: true,
    tooltipLabelFormat: '%B %-d, %Y',
    tooltipValueFormat: ',',
    xFormat: '%d',
    x2Format: '%b %Y',
    currency: {
        symbol: '$',
        symbolPosition: 'left',
        decimalSeparator: '.',
        thousandSeparator: ',',
    },
};
exports.default = (0, viewport_1.withViewportMatch)({
    isViewportMobile: '< medium',
    isViewportLarge: '>= large',
    isViewportWide: '>= wide',
})(Chart);
