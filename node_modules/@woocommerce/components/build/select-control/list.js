"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * External dependencies
 */
const components_1 = require("@wordpress/components");
const classnames_1 = __importDefault(require("classnames"));
const element_1 = require("@wordpress/element");
const lodash_1 = require("lodash");
const keycodes_1 = require("@wordpress/keycodes");
const prop_types_1 = __importDefault(require("prop-types"));
/**
 * A list box that displays filtered options after search.
 */
class List extends element_1.Component {
    constructor() {
        super(...arguments);
        this.handleKeyDown = this.handleKeyDown.bind(this);
        this.select = this.select.bind(this);
        this.optionRefs = {};
        this.listbox = (0, element_1.createRef)();
    }
    componentDidUpdate(prevProps) {
        const { options, selectedIndex } = this.props;
        // Remove old option refs to avoid memory leaks.
        if (!(0, lodash_1.isEqual)(options, prevProps.options)) {
            this.optionRefs = {};
        }
        if (selectedIndex !== prevProps.selectedIndex) {
            this.scrollToOption(selectedIndex);
        }
    }
    getOptionRef(index) {
        if (!this.optionRefs.hasOwnProperty(index)) {
            this.optionRefs[index] = (0, element_1.createRef)();
        }
        return this.optionRefs[index];
    }
    select(option) {
        const { onSelect } = this.props;
        if (option.isDisabled) {
            return;
        }
        onSelect(option);
    }
    scrollToOption(index) {
        const listbox = this.listbox.current;
        if (listbox.scrollHeight <= listbox.clientHeight) {
            return;
        }
        if (!this.optionRefs[index]) {
            return;
        }
        const option = this.optionRefs[index].current;
        const scrollBottom = listbox.clientHeight + listbox.scrollTop;
        const elementBottom = option.offsetTop + option.offsetHeight;
        if (elementBottom > scrollBottom) {
            listbox.scrollTop = elementBottom - listbox.clientHeight;
        }
        else if (option.offsetTop < listbox.scrollTop) {
            listbox.scrollTop = option.offsetTop;
        }
    }
    handleKeyDown(event) {
        const { decrementSelectedIndex, incrementSelectedIndex, options, onSearch, selectedIndex, setExpanded, } = this.props;
        if (options.length === 0) {
            return;
        }
        switch (event.keyCode) {
            case keycodes_1.UP:
                decrementSelectedIndex();
                event.preventDefault();
                event.stopPropagation();
                break;
            case keycodes_1.DOWN:
                incrementSelectedIndex();
                event.preventDefault();
                event.stopPropagation();
                break;
            case keycodes_1.ENTER:
                if (options[selectedIndex]) {
                    this.select(options[selectedIndex]);
                }
                event.preventDefault();
                event.stopPropagation();
                break;
            case keycodes_1.LEFT:
            case keycodes_1.RIGHT:
                setExpanded(false);
                break;
            case keycodes_1.ESCAPE:
                setExpanded(false);
                onSearch(null);
                return;
            case keycodes_1.TAB:
                if (options[selectedIndex]) {
                    this.select(options[selectedIndex]);
                }
                setExpanded(false);
                break;
            default:
        }
    }
    toggleKeyEvents(isListening) {
        const { node } = this.props;
        // This exists because we must capture ENTER key presses before RichText.
        // It seems that react fires the simulated capturing events after the
        // native browser event has already bubbled so we can't stopPropagation
        // and avoid RichText getting the event from TinyMCE, hence we must
        // register a native event handler.
        const handler = isListening
            ? 'addEventListener'
            : 'removeEventListener';
        node[handler]('keydown', this.handleKeyDown, true);
    }
    componentDidMount() {
        const { selectedIndex } = this.props;
        if (selectedIndex > -1) {
            this.scrollToOption(selectedIndex);
        }
        this.toggleKeyEvents(true);
    }
    componentWillUnmount() {
        this.toggleKeyEvents(false);
    }
    render() {
        const { instanceId, listboxId, options, selectedIndex, staticList } = this.props;
        const listboxClasses = (0, classnames_1.default)('woocommerce-select-control__listbox', {
            'is-static': staticList,
        });
        return ((0, element_1.createElement)("div", { ref: this.listbox, id: listboxId, role: "listbox", className: listboxClasses, tabIndex: "-1" }, options.map((option, index) => ((0, element_1.createElement)(components_1.Button, { ref: this.getOptionRef(index), key: option.key, id: `woocommerce-select-control__option-${instanceId}-${option.key}`, role: "option", "aria-selected": index === selectedIndex, disabled: option.isDisabled, className: (0, classnames_1.default)('woocommerce-select-control__option', {
                'is-selected': index === selectedIndex,
            }), onClick: () => this.select(option), tabIndex: "-1" }, option.label)))));
    }
}
List.propTypes = {
    /**
     * ID of the main SelectControl instance.
     */
    instanceId: prop_types_1.default.number,
    /**
     * ID used for a11y in the listbox.
     */
    listboxId: prop_types_1.default.string,
    /**
     * Parent node to bind keyboard events to.
     */
    // eslint-disable-next-line no-undef
    node: prop_types_1.default.instanceOf(Element).isRequired,
    /**
     * Function to execute when an option is selected.
     */
    onSelect: prop_types_1.default.func,
    /**
     * Array of options to display.
     */
    options: prop_types_1.default.arrayOf(prop_types_1.default.shape({
        isDisabled: prop_types_1.default.bool,
        key: prop_types_1.default.oneOfType([prop_types_1.default.number, prop_types_1.default.string])
            .isRequired,
        keywords: prop_types_1.default.arrayOf(prop_types_1.default.oneOfType([prop_types_1.default.string, prop_types_1.default.number])),
        label: prop_types_1.default.oneOfType([
            prop_types_1.default.string,
            prop_types_1.default.object,
        ]),
        value: prop_types_1.default.any,
    })).isRequired,
    /**
     * Integer for the currently selected item.
     */
    selectedIndex: prop_types_1.default.number,
    /**
     * Bool to determine if the list should be positioned absolutely or staticly.
     */
    staticList: prop_types_1.default.bool,
};
exports.default = List;
