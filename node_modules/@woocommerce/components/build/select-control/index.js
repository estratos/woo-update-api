"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SelectControl = void 0;
/**
 * External dependencies
 */
const i18n_1 = require("@wordpress/i18n");
const classnames_1 = __importDefault(require("classnames"));
const element_1 = require("@wordpress/element");
const lodash_1 = require("lodash");
const prop_types_1 = __importDefault(require("prop-types"));
const components_1 = require("@wordpress/components");
const compose_1 = require("@wordpress/compose");
/**
 * Internal dependencies
 */
const list_1 = __importDefault(require("./list"));
const tags_1 = __importDefault(require("./tags"));
const control_1 = __importDefault(require("./control"));
const initialState = { isExpanded: false, isFocused: false, query: '' };
/**
 * A search box which filters options while typing,
 * allowing a user to select from an option from a filtered list.
 */
class SelectControl extends element_1.Component {
    constructor(props) {
        super(props);
        const { selected, options, excludeSelectedOptions } = props;
        this.state = Object.assign(Object.assign({}, initialState), { searchOptions: [], selectedIndex: selected && (options === null || options === void 0 ? void 0 : options.length) && !excludeSelectedOptions
                ? options.findIndex((option) => option.key === selected)
                : null });
        this.bindNode = this.bindNode.bind(this);
        this.decrementSelectedIndex = this.decrementSelectedIndex.bind(this);
        this.incrementSelectedIndex = this.incrementSelectedIndex.bind(this);
        this.onAutofillChange = this.onAutofillChange.bind(this);
        this.updateSearchOptions = (0, lodash_1.debounce)(this.updateSearchOptions.bind(this), props.searchDebounceTime);
        this.search = this.search.bind(this);
        this.selectOption = this.selectOption.bind(this);
        this.setExpanded = this.setExpanded.bind(this);
        this.setNewValue = this.setNewValue.bind(this);
    }
    bindNode(node) {
        this.node = node;
    }
    reset(selected = this.getSelected()) {
        const { multiple, excludeSelectedOptions } = this.props;
        const newState = Object.assign({}, initialState);
        // Reset selectedIndex if single selection.
        if (!multiple && selected.length && selected[0].key) {
            newState.selectedIndex = !excludeSelectedOptions
                ? this.props.options.findIndex((i) => i.key === selected[0].key)
                : null;
        }
        this.setState(newState);
    }
    handleFocusOutside() {
        this.reset();
    }
    hasMultiple() {
        const { multiple, selected } = this.props;
        if (!multiple) {
            return false;
        }
        if (Array.isArray(selected)) {
            return selected.some((item) => Boolean(item.label));
        }
        return Boolean(selected);
    }
    getSelected() {
        const { multiple, options, selected } = this.props;
        // Return the passed value if an array is provided.
        if (multiple || Array.isArray(selected)) {
            return selected;
        }
        const selectedOption = options.find((option) => option.key === selected);
        return selectedOption ? [selectedOption] : [];
    }
    selectOption(option) {
        const { multiple, selected } = this.props;
        const newSelected = multiple ? [...selected, option] : [option];
        this.reset(newSelected);
        const oldSelected = Array.isArray(selected)
            ? selected
            : [{ key: selected }];
        const isSelected = oldSelected.findIndex((val) => val.key === option.key);
        if (isSelected === -1) {
            this.setNewValue(newSelected);
        }
        // After selecting option, the list will reset and we'd need to correct selectedIndex.
        const newSelectedIndex = this.props.excludeSelectedOptions
            ? // Since we're excluding the selected option, invalidate selection
                // so re-focusing wont immediately set it to the neigbouring option.
                null
            : this.getOptions().findIndex((i) => i.key === option.key);
        this.setState({
            selectedIndex: newSelectedIndex,
        });
    }
    setNewValue(newValue) {
        const { onChange, selected, multiple } = this.props;
        const { query } = this.state;
        // Trigger a change if the selected value is different and pass back
        // an array or string depending on the original value.
        if (multiple || Array.isArray(selected)) {
            onChange(newValue, query);
        }
        else {
            onChange(newValue.length > 0 ? newValue[0].key : '', query);
        }
    }
    decrementSelectedIndex() {
        const { selectedIndex } = this.state;
        const options = this.getOptions();
        const nextSelectedIndex = selectedIndex !== null
            ? (selectedIndex === 0 ? options.length : selectedIndex) - 1
            : options.length - 1;
        this.setState({ selectedIndex: nextSelectedIndex });
    }
    incrementSelectedIndex() {
        const { selectedIndex } = this.state;
        const options = this.getOptions();
        const nextSelectedIndex = selectedIndex !== null ? (selectedIndex + 1) % options.length : 0;
        this.setState({ selectedIndex: nextSelectedIndex });
    }
    announce(searchOptions) {
        const { debouncedSpeak } = this.props;
        if (!debouncedSpeak) {
            return;
        }
        if (!!searchOptions.length) {
            debouncedSpeak((0, i18n_1.sprintf)((0, i18n_1._n)('%d result found, use up and down arrow keys to navigate.', '%d results found, use up and down arrow keys to navigate.', searchOptions.length, 'woocommerce'), searchOptions.length), 'assertive');
        }
        else {
            debouncedSpeak((0, i18n_1.__)('No results.', 'woocommerce'), 'assertive');
        }
    }
    getOptions() {
        const { isSearchable, options, excludeSelectedOptions } = this.props;
        const { searchOptions } = this.state;
        const selectedKeys = this.getSelected().map((option) => option.key);
        const shownOptions = isSearchable ? searchOptions : options;
        if (excludeSelectedOptions) {
            return shownOptions.filter((option) => !selectedKeys.includes(option.key));
        }
        return shownOptions;
    }
    getOptionsByQuery(options, query) {
        const { getSearchExpression, maxResults, onFilter } = this.props;
        const filtered = [];
        // Create a regular expression to filter the options.
        const expression = getSearchExpression((0, lodash_1.escapeRegExp)(query ? query.trim() : ''));
        const search = expression ? new RegExp(expression, 'i') : /^$/;
        for (let i = 0; i < options.length; i++) {
            const option = options[i];
            // Merge label into keywords
            let { keywords = [] } = option;
            if (typeof option.label === 'string') {
                keywords = [...keywords, option.label];
            }
            const isMatch = keywords.some((keyword) => search.test(keyword));
            if (!isMatch) {
                continue;
            }
            filtered.push(option);
            // Abort early if max reached
            if (maxResults && filtered.length === maxResults) {
                break;
            }
        }
        return onFilter(filtered, query);
    }
    setExpanded(value) {
        this.setState({ isExpanded: value });
    }
    search(query) {
        const cacheSearchOptions = this.cacheSearchOptions || [];
        const searchOptions = query !== null && !query.length && !this.props.hideBeforeSearch
            ? cacheSearchOptions
            : this.getOptionsByQuery(cacheSearchOptions, query);
        this.setState({
            query,
            isFocused: true,
            searchOptions,
            selectedIndex: (query === null || query === void 0 ? void 0 : query.length) > 0 ? null : this.state.selectedIndex, // Only reset selectedIndex if we're actually searching.
        }, () => {
            this.setState({
                isExpanded: Boolean(this.getOptions().length),
            });
        });
        this.updateSearchOptions(query);
    }
    updateSearchOptions(query) {
        const { hideBeforeSearch, options, onSearch } = this.props;
        const promise = (this.activePromise = Promise.resolve(onSearch(options, query)).then((promiseOptions) => {
            if (promise !== this.activePromise) {
                // Another promise has become active since this one was asked to resolve, so do nothing,
                // or else we might end triggering a race condition updating the state.
                return;
            }
            this.cacheSearchOptions = promiseOptions;
            // Get all options if `hideBeforeSearch` is enabled and query is not null.
            const searchOptions = query !== null && !query.length && !hideBeforeSearch
                ? promiseOptions
                : this.getOptionsByQuery(promiseOptions, query);
            this.setState({
                searchOptions,
                selectedIndex: (query === null || query === void 0 ? void 0 : query.length) > 0 ? null : this.state.selectedIndex, // Only reset selectedIndex if we're actually searching.
            }, () => {
                this.setState({
                    isExpanded: Boolean(this.getOptions().length),
                });
                this.announce(searchOptions);
            });
        }));
    }
    onAutofillChange(event) {
        const { options } = this.props;
        const searchOptions = this.getOptionsByQuery(options, event.target.value);
        if (searchOptions.length === 1) {
            this.selectOption(searchOptions[0]);
        }
    }
    render() {
        const { autofill, children, className, disabled, controlClassName, inlineTags, instanceId, isSearchable, options, } = this.props;
        const { isExpanded, isFocused, selectedIndex } = this.state;
        const hasMultiple = this.hasMultiple();
        const { key: selectedKey = '' } = options[selectedIndex] || {};
        const listboxId = isExpanded
            ? `woocommerce-select-control__listbox-${instanceId}`
            : null;
        const activeId = isExpanded
            ? `woocommerce-select-control__option-${instanceId}-${selectedKey}`
            : null;
        return ((0, element_1.createElement)("div", { className: (0, classnames_1.default)('woocommerce-select-control', className, {
                'has-inline-tags': hasMultiple && inlineTags,
                'is-focused': isFocused,
                'is-searchable': isSearchable,
            }), ref: this.bindNode },
            autofill && ((0, element_1.createElement)("input", { onChange: this.onAutofillChange, name: autofill, type: "text", className: "woocommerce-select-control__autofill-input", tabIndex: "-1" })),
            children,
            (0, element_1.createElement)(control_1.default, Object.assign({}, this.props, this.state, { activeId: activeId, className: controlClassName, disabled: disabled, hasTags: hasMultiple, isExpanded: isExpanded, listboxId: listboxId, onSearch: this.search, selected: this.getSelected(), onChange: this.setNewValue, setExpanded: this.setExpanded, updateSearchOptions: this.updateSearchOptions, decrementSelectedIndex: this.decrementSelectedIndex, incrementSelectedIndex: this.incrementSelectedIndex })),
            !inlineTags && hasMultiple && ((0, element_1.createElement)(tags_1.default, Object.assign({}, this.props, { selected: this.getSelected() }))),
            isExpanded && ((0, element_1.createElement)(list_1.default, Object.assign({}, this.props, this.state, { activeId: activeId, listboxId: listboxId, node: this.node, onSelect: this.selectOption, onSearch: this.search, options: this.getOptions(), decrementSelectedIndex: this.decrementSelectedIndex, incrementSelectedIndex: this.incrementSelectedIndex, setExpanded: this.setExpanded })))));
    }
}
exports.SelectControl = SelectControl;
SelectControl.propTypes = {
    /**
     * Name to use for the autofill field, not used if no string is passed.
     */
    autofill: prop_types_1.default.string,
    /**
     * A renderable component (or string) which will be displayed before the `Control` of this component.
     */
    children: prop_types_1.default.node,
    /**
     * Class name applied to parent div.
     */
    className: prop_types_1.default.string,
    /**
     * Class name applied to control wrapper.
     */
    controlClassName: prop_types_1.default.string,
    /**
     * Allow the select options to be disabled.
     */
    disabled: prop_types_1.default.bool,
    /**
     * Exclude already selected options from the options list.
     */
    excludeSelectedOptions: prop_types_1.default.bool,
    /**
     * Add or remove items to the list of options after filtering,
     * passed the array of filtered options and should return an array of options.
     */
    onFilter: prop_types_1.default.func,
    /**
     * Function to add regex expression to the filter the results, passed the search query.
     */
    getSearchExpression: prop_types_1.default.func,
    /**
     * Help text to be appended beneath the input.
     */
    help: prop_types_1.default.oneOfType([prop_types_1.default.string, prop_types_1.default.node]),
    /**
     * Render tags inside input, otherwise render below input.
     */
    inlineTags: prop_types_1.default.bool,
    /**
     * Allow the select options to be filtered by search input.
     */
    isSearchable: prop_types_1.default.bool,
    /**
     * A label to use for the main input.
     */
    label: prop_types_1.default.string,
    /**
     * Function called when selected results change, passed result list.
     */
    onChange: prop_types_1.default.func,
    /**
     * Function run after search query is updated, passed previousOptions and query,
     * should return a promise with an array of updated options.
     */
    onSearch: prop_types_1.default.func,
    /**
     * An array of objects for the options list.  The option along with its key, label and
     * value will be returned in the onChange event.
     */
    options: prop_types_1.default.arrayOf(prop_types_1.default.shape({
        isDisabled: prop_types_1.default.bool,
        key: prop_types_1.default.oneOfType([prop_types_1.default.number, prop_types_1.default.string])
            .isRequired,
        keywords: prop_types_1.default.arrayOf(prop_types_1.default.oneOfType([prop_types_1.default.string, prop_types_1.default.number])),
        label: prop_types_1.default.oneOfType([
            prop_types_1.default.string,
            prop_types_1.default.object,
        ]),
        value: prop_types_1.default.any,
    })).isRequired,
    /**
     * A placeholder for the search input.
     */
    placeholder: prop_types_1.default.string,
    /**
     * Time in milliseconds to debounce the search function after typing.
     */
    searchDebounceTime: prop_types_1.default.number,
    /**
     * An array of objects describing selected values or optionally a string for a single value.
     * If the label of the selected value is omitted, the Tag of that value will not
     * be rendered inside the search box.
     */
    selected: prop_types_1.default.oneOfType([
        prop_types_1.default.string,
        prop_types_1.default.arrayOf(prop_types_1.default.shape({
            key: prop_types_1.default.oneOfType([
                prop_types_1.default.number,
                prop_types_1.default.string,
            ]).isRequired,
            label: prop_types_1.default.string,
        })),
    ]),
    /**
     * A limit for the number of results shown in the options menu.  Set to 0 for no limit.
     */
    maxResults: prop_types_1.default.number,
    /**
     * Allow multiple option selections.
     */
    multiple: prop_types_1.default.bool,
    /**
     * Render a 'Clear' button next to the input box to remove its contents.
     */
    showClearButton: prop_types_1.default.bool,
    /**
     * The input type for the search box control.
     */
    searchInputType: prop_types_1.default.oneOf([
        'text',
        'search',
        'number',
        'email',
        'tel',
        'url',
    ]),
    /**
     * Only show list options after typing a search query.
     */
    hideBeforeSearch: prop_types_1.default.bool,
    /**
     * Show all options on focusing, even if a query exists.
     */
    showAllOnFocus: prop_types_1.default.bool,
    /**
     * Render results list positioned statically instead of absolutely.
     */
    staticList: prop_types_1.default.bool,
    /**
     * autocomplete prop for the Control input field.
     */
    autoComplete: prop_types_1.default.string,
};
SelectControl.defaultProps = {
    autofill: null,
    excludeSelectedOptions: true,
    getSearchExpression: lodash_1.identity,
    inlineTags: false,
    isSearchable: false,
    onChange: lodash_1.noop,
    onFilter: lodash_1.identity,
    onSearch: (options) => Promise.resolve(options),
    maxResults: 0,
    multiple: false,
    searchDebounceTime: 0,
    searchInputType: 'search',
    selected: [],
    showAllOnFocus: false,
    showClearButton: false,
    hideBeforeSearch: false,
    staticList: false,
    autoComplete: 'off',
};
exports.default = (0, compose_1.compose)([
    components_1.withSpokenMessages,
    compose_1.withInstanceId,
    components_1.withFocusOutside, // this MUST be the innermost HOC as it calls handleFocusOutside
])(SelectControl);
