"use strict";
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getTotalCountResourceName = exports.searchItemsByString = exports.getLeaderboard = void 0;
/**
 * External dependencies
 */
const date_1 = require("@woocommerce/date");
/**
 * Internal dependencies
 */
const constants_1 = require("./constants");
const utils_1 = require("../utils");
/**
 * Returns leaderboard data to render a leaderboard table.
 *
 * @param {Object} options                  arguments
 * @param {string} options.id               Leaderboard ID
 * @param {number} options.per_page         Per page limit
 * @param {Object} options.persisted_query  Persisted query passed to endpoint
 * @param {Object} options.query            Query parameters in the url
 * @param {Object} options.filterQuery      Query parameters to filter the leaderboard
 * @param {Object} options.select           Instance of @wordpress/select
 * @param {string} options.defaultDateRange User specified default date range.
 * @return {Object} Object containing leaderboard responses.
 */
function getLeaderboard(options) {
    const endpoint = 'leaderboards';
    const { per_page: perPage, persisted_query: persistedQuery, query, select, filterQuery, } = options;
    const { getItems, getItemsError, isResolving } = select(constants_1.STORE_NAME);
    const response = {
        isRequesting: false,
        isError: false,
        rows: [],
    };
    const datesFromQuery = (0, date_1.getCurrentDates)(query, options.defaultDateRange);
    const leaderboardQuery = Object.assign(Object.assign({}, filterQuery), { after: (0, date_1.appendTimestamp)(datesFromQuery.primary.after, 'start'), before: (0, date_1.appendTimestamp)(datesFromQuery.primary.before, 'end'), per_page: perPage, persisted_query: JSON.stringify(persistedQuery) });
    // Disable eslint rule requiring `getItems` to be defined below because the next two statements
    // depend on `getItems` to have been called.
    // eslint-disable-next-line @wordpress/no-unused-vars-before-return
    const leaderboards = getItems(endpoint, leaderboardQuery);
    if (isResolving('getItems', [endpoint, leaderboardQuery])) {
        return Object.assign(Object.assign({}, response), { isRequesting: true });
    }
    else if (getItemsError(endpoint, leaderboardQuery)) {
        return Object.assign(Object.assign({}, response), { isError: true });
    }
    const leaderboard = leaderboards.get(options.id);
    return Object.assign(Object.assign({}, response), { rows: leaderboard === null || leaderboard === void 0 ? void 0 : leaderboard.rows });
}
exports.getLeaderboard = getLeaderboard;
/**
 * Returns items based on a search query.
 *
 * @param {Object}   selector Instance of @wordpress/select response
 * @param {string}   endpoint Report API Endpoint
 * @param {string[]} search   Array of search strings.
 * @param {Object}   options  Query options.
 * @return {Object}   Object containing API request information and the matching items.
 */
function searchItemsByString(selector, endpoint, search, options = {}) {
    const { getItems, getItemsError, isResolving } = selector;
    const items = {};
    let isRequesting = false;
    let isError = false;
    search.forEach((searchWord) => {
        const query = Object.assign({ search: searchWord, per_page: 10 }, options);
        const newItems = getItems(endpoint, query);
        newItems.forEach((item, id) => {
            items[id] = item;
        });
        if (isResolving('getItems', [endpoint, query])) {
            isRequesting = true;
        }
        if (getItemsError(endpoint, query)) {
            isError = true;
        }
    });
    return { items, isRequesting, isError };
}
exports.searchItemsByString = searchItemsByString;
/**
 * Generate a resource name for item totals count.
 *
 * It omits query parameters from the identifier that don't affect
 * totals values like pagination and response field filtering.
 *
 * @param {string} itemType Item type for totals count.
 * @param {Object} query    Query for item totals count.
 * @return {string} Resource name for item totals.
 */
function getTotalCountResourceName(itemType, query) {
    const { _fields, page, per_page } = query, totalsQuery = __rest(query, ["_fields", "page", "per_page"]);
    return (0, utils_1.getResourceName)('total-' + itemType, Object.assign({}, totalsQuery));
}
exports.getTotalCountResourceName = getTotalCountResourceName;
