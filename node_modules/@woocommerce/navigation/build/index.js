"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.WooNavigationItem = exports.navigateTo = exports.parseAdminUrl = exports.isWCAdmin = exports.addHistoryListener = exports.updateQueryString = exports.onQueryChange = exports.getQuery = exports.getNewPath = exports.getSearchWords = exports.getSetOfIdsFromQuery = exports.getIdsFromQuery = exports.getScreenFromPath = exports.pathIsExcluded = exports.getQueryExcludedScreens = exports.getPersistedQuery = exports.getPath = exports.getHistory = void 0;
/**
 * External dependencies
 */
const element_1 = require("@wordpress/element");
const url_1 = require("@wordpress/url");
const qs_1 = require("qs");
const lodash_1 = require("lodash");
const hooks_1 = require("@wordpress/hooks");
const components_1 = require("@wordpress/components");
const settings_1 = require("@woocommerce/settings");
/**
 * Internal dependencies
 */
const history_1 = require("./history");
Object.defineProperty(exports, "getHistory", { enumerable: true, get: function () { return history_1.getHistory; } });
const navUtils = __importStar(require("./index"));
// Export all filter utilities
__exportStar(require("./filters"), exports);
const TIME_EXCLUDED_SCREENS_FILTER = 'woocommerce_admin_time_excluded_screens';
/**
 * Get the current path from history.
 *
 * @return {string}  Current path.
 */
const getPath = () => (0, history_1.getHistory)().location.pathname;
exports.getPath = getPath;
/**
 * Gets query parameters that should persist between screens or updates
 * to reports, such as filtering.
 *
 * @param {Object} query Query containing the parameters.
 * @return {Object} Object containing the persisted queries.
 */
const getPersistedQuery = (query = navUtils.getQuery()) => {
    /**
     * Filter persisted queries. These query parameters remain in the url when other parameters are updated.
     *
     * @filter woocommerce_admin_persisted_queries
     * @param {Array.<string>} persistedQueries Array of persisted queries.
     */
    const params = (0, hooks_1.applyFilters)('woocommerce_admin_persisted_queries', [
        'period',
        'compare',
        'before',
        'after',
        'interval',
        'type',
    ]);
    return (0, lodash_1.pick)(query, params);
};
exports.getPersistedQuery = getPersistedQuery;
/**
 * Get array of screens that should ignore persisted queries
 *
 * @return {Array} Array containing list of screens
 */
const getQueryExcludedScreens = () => (0, hooks_1.applyFilters)(TIME_EXCLUDED_SCREENS_FILTER, [
    'stock',
    'settings',
    'customers',
    'homescreen',
]);
exports.getQueryExcludedScreens = getQueryExcludedScreens;
/**
 * Given a path, return whether it is an excluded screen
 *
 * @param {Object} path Path to check
 *
 * @return {boolean} Boolean representing whether path is excluded
 */
const pathIsExcluded = (path) => (0, exports.getQueryExcludedScreens)().includes((0, exports.getScreenFromPath)(path));
exports.pathIsExcluded = pathIsExcluded;
/**
 * Retrieve a string 'name' representing the current screen
 *
 * @param {Object} path Path to resolve, default to current
 * @return {string} Screen name
 */
const getScreenFromPath = (path = (0, exports.getPath)()) => {
    return path === '/'
        ? 'homescreen'
        : path.replace('/analytics', '').replace('/', '');
};
exports.getScreenFromPath = getScreenFromPath;
/**
 * Get an array of IDs from a comma-separated query parameter.
 *
 * @param {string} [queryString=''] string value extracted from URL.
 * @return {Array<number>} List of IDs converted to an array of unique integers.
 */
function getIdsFromQuery(queryString = '') {
    return [...getSetOfIdsFromQuery(queryString)];
}
exports.getIdsFromQuery = getIdsFromQuery;
/**
 * Get an array of IDs from a comma-separated query parameter.
 *
 * @param {string} [queryString=''] string value extracted from URL.
 * @return {Set<number>} List of IDs converted to a set of integers.
 */
function getSetOfIdsFromQuery(queryString = '') {
    return new Set(// Return only unique ids.
    queryString
        .split(',')
        .map((id) => parseInt(id, 10))
        .filter((id) => !isNaN(id)));
}
exports.getSetOfIdsFromQuery = getSetOfIdsFromQuery;
/**
 * Get an array of searched words given a query.
 *
 * @param {Object} query Query object.
 * @return {Array} List of search words.
 */
function getSearchWords(query = navUtils.getQuery()) {
    if (typeof query !== 'object') {
        throw new Error('Invalid parameter passed to getSearchWords, it expects an object or no parameters.');
    }
    const { search } = query;
    if (!search) {
        return [];
    }
    if (typeof search !== 'string') {
        throw new Error("Invalid 'search' type. getSearchWords expects query's 'search' property to be a string.");
    }
    return search
        .split(',')
        .map((searchWord) => searchWord.replace('%2C', ','));
}
exports.getSearchWords = getSearchWords;
/**
 * Return a URL with set query parameters.
 *
 * @param {Object} query        object of params to be updated.
 * @param {string} path         Relative path (defaults to current path).
 * @param {Object} currentQuery object of current query params (defaults to current querystring).
 * @param {string} page         Page key (defaults to "wc-admin")
 * @return {string}  Updated URL merging query params into existing params.
 */
function getNewPath(query, path = (0, exports.getPath)(), currentQuery = getQuery(), page = 'wc-admin') {
    const args = Object.assign(Object.assign({ page }, currentQuery), query);
    if (path !== '/') {
        args.path = path;
    }
    return (0, url_1.addQueryArgs)('admin.php', args);
}
exports.getNewPath = getNewPath;
/**
 * Get the current query string, parsed into an object, from history.
 *
 * @return {Object}  Current query object, defaults to empty object.
 */
function getQuery() {
    const search = (0, history_1.getHistory)().location.search;
    if (search.length) {
        return (0, qs_1.parse)(search.substring(1)) || {};
    }
    return {};
}
exports.getQuery = getQuery;
/**
 * This function returns an event handler for the given `param`
 *
 * @param {string} param The parameter in the querystring which should be updated (ex `page`, `per_page`)
 * @param {string} path  Relative path (defaults to current path).
 * @param {string} query object of current query params (defaults to current querystring).
 * @return {Function} A callback which will update `param` to the passed value when called.
 */
function onQueryChange(param, path = (0, exports.getPath)(), query = getQuery()) {
    switch (param) {
        case 'sort':
            return (key, dir) => updateQueryString({ orderby: key, order: dir }, path, query);
        case 'compare':
            return (key, queryParam, ids) => updateQueryString({
                [queryParam]: `compare-${key}`,
                [key]: ids,
                search: undefined,
            }, path, query);
        default:
            return (value) => updateQueryString({ [param]: value }, path, query);
    }
}
exports.onQueryChange = onQueryChange;
/**
 * Updates the query parameters of the current page.
 *
 * @param {Object} query        object of params to be updated.
 * @param {string} path         Relative path (defaults to current path).
 * @param {Object} currentQuery object of current query params (defaults to current querystring).
 * @param {string} page         Page key (defaults to "wc-admin")
 */
function updateQueryString(query, path = (0, exports.getPath)(), currentQuery = getQuery(), page = 'wc-admin') {
    const newPath = getNewPath(query, path, currentQuery, page);
    (0, history_1.getHistory)().push(newPath);
}
exports.updateQueryString = updateQueryString;
/**
 * Adds a listener that runs on history change.
 *
 * @param {Function} listener Listener to add on history change.
 * @return {Function} Function to remove listeners.
 */
const addHistoryListener = (listener) => {
    // Monkey patch pushState to allow trigger the pushstate event listener.
    var _a;
    window.wcNavigation = (_a = window.wcNavigation) !== null && _a !== void 0 ? _a : {};
    if (!window.wcNavigation.historyPatched) {
        ((history) => {
            /* global CustomEvent */
            const pushState = history.pushState;
            const replaceState = history.replaceState;
            history.pushState = function (state) {
                const pushStateEvent = new CustomEvent('pushstate', {
                    state,
                });
                window.dispatchEvent(pushStateEvent);
                return pushState.apply(history, arguments);
            };
            history.replaceState = function (state) {
                const replaceStateEvent = new CustomEvent('replacestate', {
                    state,
                });
                window.dispatchEvent(replaceStateEvent);
                return replaceState.apply(history, arguments);
            };
            window.wcNavigation.historyPatched = true;
        })(window.history);
    }
    window.addEventListener('popstate', listener);
    window.addEventListener('pushstate', listener);
    window.addEventListener('replacestate', listener);
    return () => {
        window.removeEventListener('popstate', listener);
        window.removeEventListener('pushstate', listener);
        window.removeEventListener('replacestate', listener);
    };
};
exports.addHistoryListener = addHistoryListener;
/**
 * Determines if a URL is a WC admin url.
 *
 * @param {*} url - the url to test
 * @return {boolean} true if the url is a wc-admin URL
 */
const isWCAdmin = (url = window.location.href) => {
    return /admin.php\?page=wc-admin/.test(url);
};
exports.isWCAdmin = isWCAdmin;
/**
 * Returns a parsed object for an absolute or relative admin URL.
 *
 * @param {*} url - the url to test.
 * @return {Object} - the URL object of the given url.
 */
const parseAdminUrl = (url) => {
    if (url.startsWith('http')) {
        return new URL(url);
    }
    return /^\/?[a-z0-9]+.php/i.test(url)
        ? new URL(`${window.wcSettings.adminUrl}${url}`)
        : new URL((0, settings_1.getAdminLink)(getNewPath({}, url, {})));
};
exports.parseAdminUrl = parseAdminUrl;
/**
 * A utility function that navigates to a page, using a redirect
 * or the router as appropriate.
 *
 * @param {Object} args     - All arguments.
 * @param {string} args.url - Relative path or absolute url to navigate to
 */
const navigateTo = ({ url }) => {
    const parsedUrl = (0, exports.parseAdminUrl)(url);
    if ((0, exports.isWCAdmin)() && (0, exports.isWCAdmin)(String(parsedUrl))) {
        window.document.documentElement.scrollTop = 0;
        (0, history_1.getHistory)().push(`admin.php${parsedUrl.search}`);
        return;
    }
    window.location.href = String(parsedUrl);
};
exports.navigateTo = navigateTo;
/**
 * A Fill for extensions to add client facing custom Navigation Items.
 *
 * @slotFill WooNavigationItem
 * @scope woocommerce-navigation
 * @param {Object} props          React props.
 * @param {Array}  props.children Node children.
 * @param {string} props.item     Navigation item slug.
 */
const WooNavigationItem = ({ children, item }) => {
    return (0, element_1.createElement)(components_1.Fill, { name: 'woocommerce_navigation_' + item }, children);
};
exports.WooNavigationItem = WooNavigationItem;
exports.WooNavigationItem.Slot = ({ name }) => ((0, element_1.createElement)(components_1.Slot, { name: 'woocommerce_navigation_' + name }));
