"use strict";
/* eslint-disable @typescript-eslint/no-explicit-any */
Object.defineProperty(exports, "__esModule", { value: true });
exports.getGenericSuperPropsGetter = exports.recordTracksPageViewWithPageParams = exports.recordTracksPageView = exports.recordTracksEvent = exports.signalUserFromAnotherProduct = exports.identifyUser = exports.initializeAnalytics = exports.getTracksAnonymousUserId = exports.analyticsEvents = exports.pushEventToTracksQueue = exports.getTracksLoadPromise = void 0;
const tslib_1 = require("tslib");
const events_1 = require("events");
const load_script_1 = require("@automattic/load-script");
const cookie_1 = tslib_1.__importDefault(require("cookie"));
const page_view_params_1 = require("./page-view-params");
const current_user_1 = require("./utils/current-user");
const debug_1 = tslib_1.__importDefault(require("./utils/debug"));
const do_not_track_1 = tslib_1.__importDefault(require("./utils/do-not-track"));
const get_tracking_prefs_1 = tslib_1.__importDefault(require("./utils/get-tracking-prefs"));
/**
 * Tracks uses a bunch of special query params that should not be used as property name
 * See internal Nosara repo?
 */
const TRACKS_SPECIAL_PROPS_NAMES = ['geo', 'message', 'request', 'geocity', 'ip'];
const ALLOWED_EVENT_SOURCES = ['calypso', 'jetpack', 'remotedatablocks', 'wpcom_dsp_widget'];
const EVENT_NAME_EXCEPTIONS = [
    'a8c_cookie_banner_ok',
    'a8c_cookie_banner_view',
    'a8c_ccpa_optout',
    // WooCommerce Onboarding / Connection Flow.
    'wcadmin_storeprofiler_create_jetpack_account',
    'wcadmin_storeprofiler_connect_store',
    'wcadmin_storeprofiler_login_jetpack_account',
    'wcadmin_storeprofiler_payment_login',
    'wcadmin_storeprofiler_payment_create_account',
    // Checkout
    'calypso_checkout_switch_to_p_24',
    'calypso_checkout_composite_p24_submit_clicked',
    // Launch Bar
    'wpcom_launchbar_button_click',
    // Request for free migration
    'wpcom_support_free_migration_request_click',
];
let _superProps; // Added to all Tracks events.
let _loadTracksResult = Promise.resolve(); // default value for non-BOM environments.
if (typeof document !== 'undefined') {
    _loadTracksResult = (0, load_script_1.loadScript)('//stats.wp.com/w.js?67');
}
function createRandomId(randomBytesLength = 9) {
    if (typeof window === 'undefined') {
        return '';
    }
    // 9 * 4/3 = 12
    // this is to avoid getting padding of a random byte string when it is base64 encoded
    let randomBytes;
    if (window.crypto && window.crypto.getRandomValues) {
        randomBytes = new Uint8Array(randomBytesLength);
        window.crypto.getRandomValues(randomBytes);
    }
    else {
        randomBytes = Array(randomBytesLength)
            .fill(0)
            .map(() => Math.floor(Math.random() * 256));
    }
    return window.btoa(String.fromCharCode(...randomBytes));
}
function getUrlParameter(name) {
    if (typeof window === 'undefined') {
        return '';
    }
    name = name.replace(/[[]/g, '\\[').replace(/[\]]/g, '\\]');
    const regex = new RegExp('[\\?&]' + name + '=([^&#]*)');
    const results = regex.exec(window.location.search);
    return results === null ? '' : decodeURIComponent(results[1].replace(/\+/g, ' '));
}
function checkForBlockedTracks() {
    // Proceed only after the tracks script load finished and failed.
    // Calling this function from `initialize` ensures current user is set.
    // This detects stats blocking, and identifies by `getCurrentUser()`, URL, or cookie.
    return _loadTracksResult.catch(() => {
        let _ut;
        let _ui;
        const currentUser = (0, current_user_1.getCurrentUser)();
        if (currentUser && currentUser.ID) {
            _ut = 'wpcom:user_id';
            _ui = currentUser.ID;
        }
        else {
            _ut = getUrlParameter('_ut') || 'anon';
            _ui = getUrlParameter('_ui');
            if (!_ui) {
                const cookies = cookie_1.default.parse(document.cookie);
                if (cookies.tk_ai) {
                    _ui = cookies.tk_ai;
                }
                else {
                    const randomIdLength = 18; // 18 * 4/3 = 24 (base64 encoded chars).
                    _ui = createRandomId(randomIdLength);
                    document.cookie = cookie_1.default.serialize('tk_ai', _ui);
                }
            }
        }
        (0, debug_1.default)('Loading /nostats.js', { _ut, _ui });
        return (0, load_script_1.loadScript)('/nostats.js?_ut=' + encodeURIComponent(_ut) + '&_ui=' + encodeURIComponent(_ui));
    });
}
/**
 * Returns a promise that marks whether and when the external Tracks script loads.
 */
function getTracksLoadPromise() {
    return _loadTracksResult;
}
exports.getTracksLoadPromise = getTracksLoadPromise;
function pushEventToTracksQueue(args) {
    if (typeof window !== 'undefined') {
        window._tkq = window._tkq || [];
        window._tkq.push(args);
    }
}
exports.pushEventToTracksQueue = pushEventToTracksQueue;
exports.analyticsEvents = new events_1.EventEmitter();
/**
 * Returns the anoymous id stored in the `tk_ai` cookie
 * @returns The Tracks anonymous user id
 */
function getTracksAnonymousUserId() {
    const cookies = cookie_1.default.parse(document.cookie);
    return cookies.tk_ai;
}
exports.getTracksAnonymousUserId = getTracksAnonymousUserId;
function initializeAnalytics(currentUser, superProps) {
    // Update super props.
    if ('function' === typeof superProps) {
        (0, debug_1.default)('superProps', superProps);
        _superProps = superProps;
    }
    // Identify current user.
    if ('object' === typeof currentUser) {
        (0, debug_1.default)('identifyUser', currentUser);
        identifyUser(currentUser);
    }
    const tracksLinkerId = getUrlParameter('_tkl');
    if (tracksLinkerId && tracksLinkerId !== getTracksAnonymousUserId()) {
        // Link tk_ai anonymous ids if _tkl parameter is present in URL and ids between pages are different (e.g. cross-domain)
        signalUserFromAnotherProduct(tracksLinkerId, 'anon');
    }
    // Tracks blocked?
    (0, debug_1.default)('checkForBlockedTracks');
    return checkForBlockedTracks();
}
exports.initializeAnalytics = initializeAnalytics;
function identifyUser(userData) {
    // Ensure object.
    if ('object' !== typeof userData) {
        (0, debug_1.default)('Invalid userData.', userData);
        return; // Not possible.
    }
    // Set current user.
    const currentUser = (0, current_user_1.setCurrentUser)(userData);
    if (!currentUser) {
        (0, debug_1.default)('Insufficient userData.', userData);
        return; // Not possible.
    }
    // Tracks user identification.
    (0, debug_1.default)('Tracks identifyUser.', currentUser);
    pushEventToTracksQueue(['identifyUser', currentUser.ID, currentUser.username]);
}
exports.identifyUser = identifyUser;
/**
 * For tracking users between our products, generally passing the id via a request parameter.
 *
 * Use 'anon' for userIdType for anonymous users.
 */
function signalUserFromAnotherProduct(userId, userIdType) {
    (0, debug_1.default)('Tracks signalUserFromAnotherProduct.', userId, userIdType);
    pushEventToTracksQueue(['signalAliasUserGeneral', userId, userIdType]);
}
exports.signalUserFromAnotherProduct = signalUserFromAnotherProduct;
function recordTracksEvent(eventName, eventProperties) {
    eventProperties = eventProperties || {};
    const currentUser = (0, current_user_1.getCurrentUser)();
    if (currentUser?.localeSlug) {
        eventProperties['user_lang'] = currentUser.localeSlug;
    }
    const trackingPrefs = (0, get_tracking_prefs_1.default)();
    if (!trackingPrefs?.buckets.analytics) {
        (0, debug_1.default)('Analytics has been disabled - Ignoring event "%s" with actual props %o', eventName, eventProperties);
        return;
    }
    if (process.env.NODE_ENV !== 'production' && typeof console !== 'undefined') {
        if (!isValidEventName(eventName) && !EVENT_NAME_EXCEPTIONS.includes(eventName)) {
            // eslint-disable-next-line no-console
            console.error('Tracks: Event `%s` will be ignored because it does not match with the naming convention and is ' +
                'not a listed exception. Please use a compliant event name.', eventName);
        }
        for (const key in eventProperties) {
            if (eventProperties[key] !== null && typeof eventProperties[key] === 'object') {
                const errorMessage = `Tracks: Unable to record event "${eventName}" because nested ` +
                    `properties are not supported by Tracks. Check '${key}' on`;
                // eslint-disable-next-line no-console
                console.error(errorMessage, eventProperties);
                return;
            }
            if (!/^[a-z_][a-z0-9_]*$/.test(key)) {
                // eslint-disable-next-line no-console
                console.error('Tracks: Event `%s` will be rejected because property name `%s` does not match /^[a-z_][a-z0-9_]*$/. ' +
                    'Please use a compliant property name.', eventName, key);
            }
            if (TRACKS_SPECIAL_PROPS_NAMES.indexOf(key) !== -1) {
                // eslint-disable-next-line no-console
                console.error("Tracks: Event property `%s` will be overwritten because it uses one of Tracks' internal prop name: %s. " +
                    'Please use another property name.', key, TRACKS_SPECIAL_PROPS_NAMES.join(', '));
            }
        }
    }
    (0, debug_1.default)('Record event "%s" called with props %o', eventName, eventProperties);
    if (!isValidEventSource(eventName) && !EVENT_NAME_EXCEPTIONS.includes(eventName)) {
        (0, debug_1.default)('- Event name must be prefixed by a known source or added to `EVENT_NAME_EXCEPTIONS`');
        return;
    }
    if (_superProps) {
        const superProperties = _superProps(eventProperties);
        eventProperties = { ...eventProperties, ...superProperties }; // assign to a new object so we don't modify the argument
    }
    // Remove properties that have an undefined value
    // This allows a caller to easily remove properties from the recorded set by setting them to undefined
    eventProperties = Object.fromEntries(Object.entries(eventProperties).filter(([, val]) => typeof val !== 'undefined'));
    (0, debug_1.default)('Recording event "%s" with actual props %o', eventName, eventProperties);
    pushEventToTracksQueue(['recordEvent', eventName, eventProperties]);
    exports.analyticsEvents.emit('record-event', eventName, eventProperties);
}
exports.recordTracksEvent = recordTracksEvent;
/**
 * Checks if the event name follows the Tracks naming convention.
 */
function isValidEventName(eventName) {
    return ALLOWED_EVENT_SOURCES.some((eventSource) => new RegExp(`^${eventSource}(?:_[a-z0-9]+){2,}$`).test(eventName));
}
/**
 * Checks if the event name has a valid source prefix.
 */
function isValidEventSource(eventName) {
    return ALLOWED_EVENT_SOURCES.some((eventSource) => eventName.startsWith(`${eventSource}_`));
}
function recordTracksPageView(urlPath, params) {
    (0, debug_1.default)('Recording pageview in tracks.', urlPath, params);
    let eventProperties = {
        do_not_track: (0, do_not_track_1.default)() ? 1 : 0,
        path: urlPath,
    };
    // Add calypso build timestamp if set
    const build_timestamp = typeof window !== 'undefined' && window.BUILD_TIMESTAMP;
    if (build_timestamp) {
        eventProperties = Object.assign(eventProperties, { build_timestamp });
    }
    // add optional path params
    if (params) {
        eventProperties = Object.assign(eventProperties, params);
    }
    // Record some query parameters as event properties on the page view event
    // so we can analyze their performance with our analytics tools
    if (typeof window !== 'undefined' && window.location) {
        const urlParams = new URL(window.location.href).searchParams;
        // Record all `utm` marketing params.
        const utmParamEntries = urlParams &&
            Array.from(urlParams.entries()).filter(([key]) => key.startsWith('utm_'));
        const utmParams = utmParamEntries ? Object.fromEntries(utmParamEntries) : {};
        // Record the 'ref' param.
        const refParam = urlParams && urlParams.get('ref') ? { ref: urlParams.get('ref') } : {};
        eventProperties = Object.assign(eventProperties, { ...utmParams, ...refParam });
    }
    recordTracksEvent('calypso_page_view', eventProperties);
}
exports.recordTracksPageView = recordTracksPageView;
function recordTracksPageViewWithPageParams(urlPath, params) {
    const pageViewParams = (0, page_view_params_1.getPageViewParams)(urlPath);
    recordTracksPageView(urlPath, Object.assign(params || {}, pageViewParams));
}
exports.recordTracksPageViewWithPageParams = recordTracksPageViewWithPageParams;
function getGenericSuperPropsGetter(config) {
    return () => {
        const superProps = {
            environment: process.env.NODE_ENV,
            environment_id: config('env_id'),
            site_id_label: 'wpcom',
            client: config('client_slug'),
        };
        if (typeof window !== 'undefined') {
            Object.assign(superProps, {
                vph: window.innerHeight,
                vpw: window.innerWidth,
            });
        }
        return superProps;
    };
}
exports.getGenericSuperPropsGetter = getGenericSuperPropsGetter;
//# sourceMappingURL=tracks.js.map