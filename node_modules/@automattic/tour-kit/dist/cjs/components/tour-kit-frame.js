"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const jsx_runtime_1 = require("react/jsx-runtime");
/**
 * External Dependencies
 */
const viewport_react_1 = require("@automattic/viewport-react");
const element_1 = require("@wordpress/element");
const classnames_1 = tslib_1.__importDefault(require("classnames"));
const react_popper_1 = require("react-popper");
/**
 * Internal Dependencies
 */
const use_step_tracking_1 = tslib_1.__importDefault(require("../hooks/use-step-tracking"));
const utils_1 = require("../utils");
const live_resize_modifier_1 = require("../utils/live-resize-modifier");
const keyboard_navigation_1 = tslib_1.__importDefault(require("./keyboard-navigation"));
const tour_kit_minimized_1 = tslib_1.__importDefault(require("./tour-kit-minimized"));
const tour_kit_overlay_1 = tslib_1.__importDefault(require("./tour-kit-overlay"));
const tour_kit_spotlight_1 = tslib_1.__importDefault(require("./tour-kit-spotlight"));
const tour_kit_step_1 = tslib_1.__importDefault(require("./tour-kit-step"));
const handleCallback = (currentStepIndex, callback) => {
    typeof callback === 'function' && callback(currentStepIndex);
};
const TourKitFrame = ({ config }) => {
    const [currentStepIndex, setCurrentStepIndex] = (0, element_1.useState)(0);
    const [initialFocusedElement, setInitialFocusedElement] = (0, element_1.useState)(null);
    const [isMinimized, setIsMinimized] = (0, element_1.useState)(config.isMinimized ?? false);
    const [popperElement, setPopperElement] = (0, element_1.useState)(null);
    const [tourReady, setTourReady] = (0, element_1.useState)(false);
    const tourContainerRef = (0, element_1.useRef)(null);
    const isMobile = (0, viewport_react_1.useMobileBreakpoint)();
    const lastStepIndex = config.steps.length - 1;
    const referenceElements = config.steps[currentStepIndex].referenceElements;
    const referenceElementSelector = referenceElements?.[isMobile ? 'mobile' : 'desktop'] || referenceElements?.desktop;
    const referenceElement = referenceElementSelector
        ? document.querySelector(referenceElementSelector)
        : null;
    (0, element_1.useEffect)(() => {
        if (config.isMinimized) {
            setIsMinimized(true);
        }
    }, [config.isMinimized]);
    const showArrowIndicator = (0, element_1.useCallback)(() => {
        if (config.options?.effects?.arrowIndicator === false) {
            return false;
        }
        return !!(referenceElement && !isMinimized && tourReady);
    }, [config.options?.effects?.arrowIndicator, isMinimized, referenceElement, tourReady]);
    const showSpotlight = (0, element_1.useCallback)(() => {
        if (!config.options?.effects?.spotlight) {
            return false;
        }
        return !isMinimized;
    }, [config.options?.effects?.spotlight, isMinimized]);
    const showOverlay = (0, element_1.useCallback)(() => {
        if (showSpotlight() || !config.options?.effects?.overlay) {
            return false;
        }
        return !isMinimized;
    }, [config.options?.effects?.overlay, isMinimized, showSpotlight]);
    const handleDismiss = (0, element_1.useCallback)((source) => {
        return () => {
            config.closeHandler(config.steps, currentStepIndex, source);
        };
    }, [config, currentStepIndex]);
    const handleNextStepProgression = (0, element_1.useCallback)(() => {
        let newStepIndex = currentStepIndex;
        if (lastStepIndex > currentStepIndex) {
            newStepIndex = currentStepIndex + 1;
            setCurrentStepIndex(newStepIndex);
        }
        handleCallback(newStepIndex, config.options?.callbacks?.onNextStep);
    }, [config.options?.callbacks?.onNextStep, currentStepIndex, lastStepIndex]);
    const handlePreviousStepProgression = (0, element_1.useCallback)(() => {
        let newStepIndex = currentStepIndex;
        if (currentStepIndex > 0) {
            newStepIndex = currentStepIndex - 1;
            setCurrentStepIndex(newStepIndex);
        }
        handleCallback(newStepIndex, config.options?.callbacks?.onPreviousStep);
    }, [config.options?.callbacks?.onPreviousStep, currentStepIndex]);
    const handleGoToStep = (0, element_1.useCallback)((stepIndex) => {
        setCurrentStepIndex(stepIndex);
        handleCallback(stepIndex, config.options?.callbacks?.onGoToStep);
    }, [config.options?.callbacks?.onGoToStep, currentStepIndex]);
    const handleMinimize = (0, element_1.useCallback)(() => {
        setIsMinimized(true);
        handleCallback(currentStepIndex, config.options?.callbacks?.onMinimize);
    }, [config.options?.callbacks?.onMinimize, currentStepIndex]);
    const handleMaximize = (0, element_1.useCallback)(() => {
        setIsMinimized(false);
        handleCallback(currentStepIndex, config.options?.callbacks?.onMaximize);
    }, [config.options?.callbacks?.onMaximize, currentStepIndex]);
    const { styles: popperStyles, attributes: popperAttributes, update: popperUpdate, } = (0, react_popper_1.usePopper)(referenceElement, popperElement, {
        strategy: 'fixed',
        placement: config?.placement ?? 'bottom',
        modifiers: [
            {
                name: 'preventOverflow',
                options: {
                    rootBoundary: 'document',
                    padding: 16, // same as the left/margin of the tour frame
                },
            },
            {
                name: 'arrow',
                options: {
                    padding: 12,
                },
            },
            {
                name: 'offset',
                options: {
                    offset: [0, showArrowIndicator() ? 12 : 10],
                },
            },
            {
                name: 'flip',
                options: {
                    fallbackPlacements: ['top', 'left', 'right'],
                },
            },
            (0, element_1.useMemo)(() => (0, live_resize_modifier_1.liveResizeModifier)(config.options?.effects?.liveResize), [config.options?.effects?.liveResize]),
            ...(config.options?.popperModifiers || []),
        ],
    });
    const stepRepositionProps = !isMinimized && referenceElement && tourReady
        ? {
            style: popperStyles?.popper,
            ...popperAttributes?.popper,
        }
        : null;
    const arrowPositionProps = !isMinimized && referenceElement && tourReady
        ? {
            style: popperStyles?.arrow,
            ...popperAttributes?.arrow,
        }
        : null;
    /*
     * Focus first interactive element when step renders.
     */
    (0, element_1.useEffect)(() => {
        setTimeout(() => initialFocusedElement?.focus());
    }, [initialFocusedElement]);
    /*
     * Fixes issue with Popper misplacing the instance on mount
     * See: https://stackoverflow.com/questions/65585859/react-popper-incorrect-position-on-mount
     */
    (0, element_1.useEffect)(() => {
        // If no reference element to position step near
        if (!referenceElement) {
            setTourReady(true);
            return;
        }
        setTourReady(false);
        if (popperUpdate) {
            popperUpdate()
                .then(() => setTourReady(true))
                .catch(() => setTourReady(true));
        }
    }, [popperUpdate, referenceElement]);
    (0, element_1.useEffect)(() => {
        if (referenceElement && config.options?.effects?.autoScroll) {
            referenceElement.scrollIntoView(config.options.effects.autoScroll);
        }
    }, [config.options?.effects?.autoScroll, referenceElement]);
    const classes = (0, classnames_1.default)('tour-kit-frame', isMobile ? 'is-mobile' : 'is-desktop', { 'is-visible': tourReady }, (0, utils_1.classParser)(config.options?.classNames));
    (0, use_step_tracking_1.default)(currentStepIndex, config.options?.callbacks?.onStepViewOnce);
    (0, element_1.useEffect)(() => {
        if (config.options?.callbacks?.onStepView) {
            handleCallback(currentStepIndex, config.options?.callbacks?.onStepView);
        }
    }, [config.options?.callbacks?.onStepView, currentStepIndex]);
    return ((0, jsx_runtime_1.jsxs)(jsx_runtime_1.Fragment, { children: [(0, jsx_runtime_1.jsx)(keyboard_navigation_1.default, { onMinimize: handleMinimize, onDismiss: handleDismiss, onNextStepProgression: handleNextStepProgression, onPreviousStepProgression: handlePreviousStepProgression, tourContainerRef: tourContainerRef, isMinimized: isMinimized }), (0, jsx_runtime_1.jsxs)("div", { className: classes, ref: tourContainerRef, children: [showOverlay() && (0, jsx_runtime_1.jsx)(tour_kit_overlay_1.default, { visible: true }), showSpotlight() && ((0, jsx_runtime_1.jsx)(tour_kit_spotlight_1.default, { referenceElement: referenceElement, liveResize: config.options?.effects?.liveResize || {}, ...(config.options?.effects?.spotlight || {}) })), (0, jsx_runtime_1.jsxs)("div", { className: "tour-kit-frame__container", ref: setPopperElement, ...stepRepositionProps, children: [showArrowIndicator() && ((0, jsx_runtime_1.jsx)("div", { className: "tour-kit-frame__arrow", "data-popper-arrow": true, ...arrowPositionProps })), !isMinimized ? ((0, jsx_runtime_1.jsx)(tour_kit_step_1.default, { config: config, steps: config.steps, currentStepIndex: currentStepIndex, onMinimize: handleMinimize, onDismiss: handleDismiss, onNextStep: handleNextStepProgression, onPreviousStep: handlePreviousStepProgression, onGoToStep: handleGoToStep, setInitialFocusedElement: setInitialFocusedElement })) : ((0, jsx_runtime_1.jsx)(tour_kit_minimized_1.default, { config: config, steps: config.steps, currentStepIndex: currentStepIndex, onMaximize: handleMaximize, onDismiss: handleDismiss }))] })] })] }));
};
exports.default = TourKitFrame;
//# sourceMappingURL=tour-kit-frame.js.map