"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.useMshotsImg = exports.mshotsUrl = void 0;
const url_1 = require("@wordpress/url");
const react_1 = require("react");
const fetch_await_redirect_1 = require("./fetch-await-redirect");
function mshotsUrl(targetUrl, options, countToRefresh = 0) {
    if (!targetUrl) {
        return '';
    }
    const mshotsUrl = 'https://s0.wp.com/mshots/v1/';
    const mshotsRequest = (0, url_1.addQueryArgs)(mshotsUrl + encodeURIComponent(targetUrl), {
        ...options,
        countToRefresh,
    });
    return mshotsRequest;
}
exports.mshotsUrl = mshotsUrl;
const MAXTRIES = 10;
function getRetinaSize(multiply, { w, h }) {
    return {
        width: w * multiply,
        height: (h || w) * multiply,
    };
}
const useMshotsImg = (src, options, sizes = []) => {
    const [previousSrc, setPreviousSrc] = (0, react_1.useState)(src);
    const srcHasChanged = src !== previousSrc;
    const [retryCount, setRetryCount] = (0, react_1.useState)(0);
    const { mshotUrl, srcSet } = (0, react_1.useMemo)(() => {
        // If the src has changed, the retry count will be reset
        // and we want to avoid caching the mshot loading the image
        const count = srcHasChanged ? -1 : retryCount;
        const mshotUrl = mshotsUrl(src, options, count);
        // Add retina sizes 2x and 3x.
        const srcSet = [...sizes, getRetinaSize(2, options), getRetinaSize(3, options)]
            .map(({ width, height }) => {
            const resizedUrl = mshotsUrl(src, { ...options, w: width, h: height }, count);
            return `${resizedUrl} ${width}w`;
        })
            .join(', ');
        return { mshotUrl, srcSet };
    }, [srcHasChanged, retryCount, src, options, sizes]);
    const [isLoading, setIsLoading] = (0, react_1.useState)(true);
    const [isError, setIsError] = (0, react_1.useState)(false);
    const timeout = (0, react_1.useRef)();
    const onError = (0, react_1.useCallback)(() => {
        setIsError(true);
    }, []);
    (0, react_1.useEffect)(() => {
        if (!src) {
            return;
        }
        async function checkRedirectImage() {
            try {
                const { isError, isRedirect } = await (0, fetch_await_redirect_1.fetchAwaitRedirect)(mshotUrl);
                if (!timeout.current) {
                    return;
                }
                if (isError) {
                    setIsLoading(false);
                    setIsError(true);
                }
                // 307 is the status code for a temporary redirect used by mshots.
                // If we `follow` the redirect, the `response.url` will be 'https://s0.wp.com/mshots/v1/default'
                // and the `response.headers.get('content-type)` will be 'image/gif'
                if (!isRedirect) {
                    setIsLoading(false);
                }
            }
            catch (e) {
                setIsLoading(false);
                setIsError(true);
            }
        }
        if (isLoading && retryCount < MAXTRIES) {
            // Only refresh 10 times
            timeout.current = setTimeout(() => {
                setRetryCount((retryCount) => retryCount + 1);
                checkRedirectImage();
            }, retryCount * 600);
        }
        return () => {
            if (timeout.current) {
                clearTimeout(timeout.current);
            }
        };
    }, [isLoading, mshotUrl, retryCount, src]);
    (0, react_1.useEffect)(() => {
        // Reset state when the image src changes. e.g. When the site is updated
        if (srcHasChanged) {
            setIsLoading(true);
            setRetryCount(0);
            setPreviousSrc(src);
        }
    }, [src, srcHasChanged]);
    return {
        isLoading,
        isError,
        imgProps: {
            onError,
            srcSet,
            src: mshotUrl,
            loading: 'lazy',
        },
    };
};
exports.useMshotsImg = useMshotsImg;
//# sourceMappingURL=use-mshots-img.js.map