"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const jsx_runtime_1 = require("react/jsx-runtime");
const components_1 = require("@wordpress/components");
const icons_1 = require("@wordpress/icons");
const clsx_1 = tslib_1.__importDefault(require("clsx"));
const i18n_calypso_1 = require("i18n-calypso");
const react_1 = require("react");
require("./style.scss");
function DropdownGroup({ children, className = '', hideRatio = 0.99, showRatio = 1, rootMargin = '0px', onClick = () => null, initialActiveIndex = -1, }) {
    const classes = (0, clsx_1.default)('responsive-toolbar-group__dropdown', className);
    const containerRef = (0, react_1.useRef)(null);
    const [calculatedOnce, setCalculatedOnce] = (0, react_1.useState)(false);
    const [activeIndex, setActiveIndex] = (0, react_1.useState)(initialActiveIndex);
    const [groupedIndexes, setGroupedIndexes] = (0, react_1.useState)({});
    const { current: shadowListItems } = (0, react_1.useRef)([]);
    const translate = (0, i18n_calypso_1.useTranslate)();
    const assignRef = (index, element) => {
        shadowListItems[index] = element;
    };
    const getChildrenToRender = () => Object.keys(groupedIndexes).map((index) => ({
        index,
        grouped: groupedIndexes[index],
        child: children[parseInt(index)],
    }));
    const renderChildren = (type = 'grouped') => {
        if (type === 'all') {
            return children.map((child, index) => ((0, jsx_runtime_1.jsx)(components_1.ToolbarButton, { ref: (el) => assignRef(index, el), className: "responsive-toolbar-group__button-item", children: child }, `shadow-item-${index}`)));
        }
        return getChildrenToRender()
            .filter(({ grouped }) => !grouped)
            .map(({ index, child }) => ((0, jsx_runtime_1.jsx)(components_1.ToolbarButton, { isActive: activeIndex === parseInt(index), onClick: () => {
                setActiveIndex(parseInt(index));
                onClick(parseInt(index));
            }, className: "responsive-toolbar-group__button-item", children: child }, `button-item-${index}`)));
    };
    const maybeRenderMore = (always = false) => {
        const containGroupedIndexes = !!Object.values(groupedIndexes).find((index) => index);
        if (containGroupedIndexes || always) {
            return ((0, jsx_runtime_1.jsxs)(components_1.SlotFillProvider, { children: [(0, jsx_runtime_1.jsx)(components_1.Popover.Slot, {}), (0, jsx_runtime_1.jsx)(components_1.Dropdown, { renderToggle: ({ onToggle }) => ((0, jsx_runtime_1.jsxs)(components_1.ToolbarButton, { className: (0, clsx_1.default)('responsive-toolbar-group__more-item', 'responsive-toolbar-group__button-item'), isActive: groupedIndexes[activeIndex], onClick: () => {
                                onToggle();
                            }, children: [translate('More'), (0, jsx_runtime_1.jsx)(icons_1.Icon, { icon: icons_1.chevronDown })] })), renderContent: ({ onClose }) => ((0, jsx_runtime_1.jsx)(components_1.MenuGroup, { children: getChildrenToRender()
                                .filter(({ grouped }) => grouped)
                                .map(({ index, child }) => ((0, jsx_runtime_1.jsx)(components_1.MenuItem, { onClick: () => {
                                    setActiveIndex(parseInt(index));
                                    onClick(parseInt(index));
                                    onClose();
                                }, className: (0, clsx_1.default)('responsive-toolbar-group__menu-item', activeIndex === parseInt(index) ? 'is-selected' : ''), children: child }, `menu-item-${index}`))) })) })] }));
        }
        return;
    };
    // I have to optimize this callback so it doesn't do unnecesary updates
    const interceptionCallback = (0, react_1.useCallback)((index, entries) => {
        const entry = entries[0];
        if (index === 0) {
            return;
        }
        if (entry.intersectionRatio >= showRatio) {
            // is last child becoming visible just showcase it.
            if (index === children.length - 1) {
                setGroupedIndexes((state) => ({
                    ...state,
                    [index]: false,
                    [index - 1]: false,
                }));
            }
            else {
                setGroupedIndexes((state) => ({
                    ...state,
                    [index - 1]: false,
                }));
            }
        }
        // always hide sets of two to give space to the "more" item.
        if (entry.intersectionRatio <= hideRatio) {
            setGroupedIndexes((state) => ({
                ...state,
                [index]: true,
                [index - 1]: true,
            }));
        }
        setCalculatedOnce((calculated) => {
            if (!calculated) {
                return true;
            }
            return calculated;
        });
    }, [children, hideRatio, showRatio]);
    (0, react_1.useEffect)(() => {
        if (!containerRef.current) {
            return;
        }
        const observers = [];
        shadowListItems.forEach((listItem, index) => {
            observers[index] = new IntersectionObserver(interceptionCallback.bind(DropdownGroup, index), {
                root: containerRef.current,
                rootMargin,
                threshold: [hideRatio, showRatio],
            });
            observers[index].observe(listItem);
        });
        return () => {
            observers.forEach((observer) => observer.disconnect());
        };
    }, [shadowListItems, interceptionCallback, hideRatio, showRatio, rootMargin]);
    // Reset active on prop change from above
    (0, react_1.useEffect)(() => {
        setActiveIndex(initialActiveIndex);
    }, [initialActiveIndex]);
    return ((0, jsx_runtime_1.jsxs)("div", { className: classes, ref: containerRef, children: [(0, jsx_runtime_1.jsxs)(components_1.ToolbarGroup, { className: "responsive-toolbar-group__full-list", children: [renderChildren('all'), maybeRenderMore(true)] }), (0, jsx_runtime_1.jsxs)(components_1.ToolbarGroup, { className: (0, clsx_1.default)('responsive-toolbar-group__grouped-list', calculatedOnce ? 'is-visible' : ''), children: [renderChildren(), maybeRenderMore()] })] }));
}
exports.default = DropdownGroup;
//# sourceMappingURL=dropdown-group.js.map