"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const jsx_runtime_1 = require("react/jsx-runtime");
const clsx_1 = tslib_1.__importDefault(require("clsx"));
const lodash_1 = require("lodash");
const react_1 = require("react");
const react_dom_1 = tslib_1.__importDefault(require("react-dom"));
const item_1 = tslib_1.__importDefault(require("./item"));
/**
 * Style depenedencies
 */
require("./style.scss");
// eslint-disable-next-line @typescript-eslint/no-empty-function
const noop = () => { };
class Suggestions extends react_1.Component {
    static defaultProps = {
        query: '',
        onSuggestionItemMount: noop,
    };
    state = {
        lastSuggestions: null,
        suggestionPosition: 0,
    };
    refsCollection = {};
    static getDerivedStateFromProps(props, state) {
        if ((0, lodash_1.isEqual)(props.suggestions, state.lastSuggestions)) {
            return null;
        }
        return {
            lastSuggestions: props.suggestions,
            suggestionPosition: 0,
        };
    }
    getSuggestionsCount = () => this.props.suggestions.length;
    getOriginalIndexFromPosition = (index) => this.getCategories().reduce((foundIndex, category) => {
        if (foundIndex !== -1) {
            return foundIndex;
        }
        const suggestion = (0, lodash_1.find)(category.suggestions, { index });
        return suggestion ? suggestion.originalIndex : -1;
    }, -1);
    suggest = (originalIndex) => this.props.suggest(this.props.suggestions[originalIndex], originalIndex);
    moveSelectionDown = () => {
        const position = (this.state.suggestionPosition + 1) % this.getSuggestionsCount();
        const element = react_dom_1.default.findDOMNode(this.refsCollection['suggestion_' + position]);
        if (element instanceof Element) {
            element.scrollIntoView({ block: 'nearest' });
        }
        this.changePosition(position);
    };
    moveSelectionUp = () => {
        const position = (this.state.suggestionPosition - 1 + this.getSuggestionsCount()) %
            this.getSuggestionsCount();
        const element = react_dom_1.default.findDOMNode(this.refsCollection['suggestion_' + position]);
        if (element instanceof Element) {
            element.scrollIntoView({ block: 'nearest' });
        }
        this.changePosition(position);
    };
    changePosition = (position) => this.setState({
        suggestionPosition: position,
    });
    handleKeyEvent = (event) => {
        if (this.getSuggestionsCount() === 0) {
            return;
        }
        switch (event.key) {
            case 'ArrowDown':
                this.moveSelectionDown();
                event.preventDefault();
                break;
            case 'ArrowUp':
                this.moveSelectionUp();
                event.preventDefault();
                break;
            case 'Enter':
                this.state.suggestionPosition >= 0 &&
                    this.suggest(this.getOriginalIndexFromPosition(this.state.suggestionPosition));
                break;
        }
    };
    handleMouseDown = (originalIndex) => {
        this.suggest(originalIndex);
    };
    handleMouseOver = (suggestionPosition) => this.setState({ suggestionPosition });
    getCategories() {
        // We need to remember the original index of the suggestion according to the
        // `suggestions` prop for tracks and firing callbacks.
        const withOriginalIndex = this.props.suggestions.map((suggestion, originalIndex) => ({
            ...suggestion,
            // this will be updated later on in this function
            index: originalIndex,
            originalIndex,
        }));
        const [withCategory, withoutCategory] = (0, lodash_1.partition)(withOriginalIndex, (suggestion) => !!suggestion.category);
        // For all intents and purposes `groupBy` keeps the order stable
        // https://github.com/lodash/lodash/issues/2212
        const byCategory = (0, lodash_1.groupBy)(withCategory, (0, lodash_1.property)('category'));
        const categories = Object.entries(byCategory).map(([category, suggestions]) => ({
            category,
            categoryKey: category,
            suggestions,
        }));
        // Add uncategorised suggestions to the front, they always appear at
        // the top of the list.
        categories.unshift({
            categoryKey: '## Uncategorized ##',
            suggestions: withoutCategory,
        });
        let order = 0;
        for (const category of categories) {
            for (const suggestion of category.suggestions) {
                suggestion.index = order++;
            }
        }
        return categories;
    }
    render() {
        const { query, className, title } = this.props;
        const containerClass = (0, clsx_1.default)('suggestions', className);
        if (!this.getSuggestionsCount()) {
            return null;
        }
        return ((0, jsx_runtime_1.jsxs)("div", { className: containerClass, children: [title ? (0, jsx_runtime_1.jsx)("div", { className: "suggestions__title", children: title }) : null, this.getCategories().map(({ category, categoryKey, suggestions }, categoryIndex) => ((0, jsx_runtime_1.jsxs)(react_1.Fragment, { children: [!categoryIndex ? null : ((0, jsx_runtime_1.jsx)("div", { className: "suggestions__category-heading", children: category })), suggestions.map(({ index, label, originalIndex }) => (
                        // The parent component should handle key events and forward them to
                        // this component. See ./README.md for details.
                        // eslint-disable-next-line jsx-a11y/mouse-events-have-key-events
                        (0, jsx_runtime_1.jsx)(item_1.default, { hasHighlight: index === this.state.suggestionPosition, query: query, onMount: () => this.props.onSuggestionItemMount?.({
                                suggestionIndex: originalIndex,
                                index,
                            }), onMouseDown: () => this.handleMouseDown(originalIndex), onMouseOver: () => this.handleMouseOver(index), label: label, ref: (suggestion) => {
                                this.refsCollection['suggestion_' + index] = suggestion;
                            } }, originalIndex)))] }, categoryKey)))] }));
    }
}
exports.default = Suggestions;
//# sourceMappingURL=index.js.map