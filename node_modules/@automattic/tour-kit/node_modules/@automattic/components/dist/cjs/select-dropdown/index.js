"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SelectDropdownForwardingRef = void 0;
const tslib_1 = require("tslib");
const jsx_runtime_1 = require("react/jsx-runtime");
const clsx_1 = tslib_1.__importDefault(require("clsx"));
const lodash_1 = require("lodash");
const prop_types_1 = tslib_1.__importDefault(require("prop-types"));
const react_1 = require("react");
const uuid_1 = require("uuid");
const count_1 = tslib_1.__importDefault(require("../count"));
const gridicon_1 = tslib_1.__importDefault(require("../gridicon"));
const item_1 = tslib_1.__importDefault(require("./item"));
const label_1 = tslib_1.__importDefault(require("./label"));
const separator_1 = tslib_1.__importDefault(require("./separator"));
const proptype_1 = tslib_1.__importDefault(require("./translatable/proptype"));
require("./style.scss");
class SelectDropdown extends react_1.Component {
    static Item = item_1.default;
    static Separator = separator_1.default;
    static Label = label_1.default;
    static propTypes = {
        id: prop_types_1.default.string,
        selectedText: proptype_1.default,
        selectedIcon: prop_types_1.default.element,
        selectedCount: prop_types_1.default.number,
        selectedSecondaryIcon: prop_types_1.default.element,
        positionSelectedSecondaryIconOnRight: prop_types_1.default.bool,
        initialSelected: prop_types_1.default.string,
        className: prop_types_1.default.string,
        style: prop_types_1.default.object,
        onSelect: prop_types_1.default.func,
        onToggle: prop_types_1.default.func,
        focusSibling: prop_types_1.default.func,
        tabIndex: prop_types_1.default.number,
        disabled: prop_types_1.default.bool,
        options: prop_types_1.default.arrayOf(prop_types_1.default.shape({
            value: prop_types_1.default.string.isRequired,
            label: prop_types_1.default.oneOfType([proptype_1.default, prop_types_1.default.node]).isRequired,
            path: prop_types_1.default.string,
            icon: prop_types_1.default.element,
            secondaryIcon: prop_types_1.default.element,
            count: prop_types_1.default.number,
        })),
        isLoading: prop_types_1.default.bool,
        ariaLabel: prop_types_1.default.string,
        showSelectedOption: prop_types_1.default.bool,
        children: prop_types_1.default.node,
    };
    static defaultProps = {
        options: [],
        onSelect: lodash_1.noop,
        onToggle: lodash_1.noop,
        style: {},
        showSelectedOption: true,
    };
    instanceId = (0, uuid_1.v4)();
    state = {
        isOpen: false,
        selected: this.getInitialSelectedItem(),
    };
    itemRefs = [];
    setItemRef = (index) => (itemEl) => {
        this.itemRefs[index] = itemEl;
    };
    constructor(props) {
        super(props);
        this.dropdownContainerRef = props.innerRef ?? (0, react_1.createRef)();
    }
    componentWillUnmount() {
        window.removeEventListener('click', this.handleOutsideClick);
    }
    componentDidUpdate(prevProps, prevState) {
        if (this.state.isOpen) {
            window.addEventListener('click', this.handleOutsideClick);
        }
        else {
            window.removeEventListener('click', this.handleOutsideClick);
        }
        if (this.state.isOpen !== prevState.isOpen) {
            this.props.onToggle({
                target: this,
                open: this.state.isOpen,
            });
        }
    }
    getInitialSelectedItem() {
        // This method is only useful for the case when the component is uncontrolled, i.e., the
        // selected state is in local state as opposed to being maintained by parent container.
        // The `SelectDropdown` is uncontrolled iff the items are specified as `options` prop.
        // (And is controlled when the items are specified as `children`.)
        if (!this.props.options.length) {
            return undefined;
        }
        // Use the `initialSelected` prop if specified
        if (this.props.initialSelected) {
            return this.props.initialSelected;
        }
        // Otherwise find the first option that is an item, i.e., not label or separator
        return (0, lodash_1.get)((0, lodash_1.find)(this.props.options, (item) => item && !item.isLabel), 'value');
    }
    getSelectedText() {
        const { options, selectedText } = this.props;
        const { selected } = this.state;
        if (selectedText) {
            return selectedText;
        }
        // return currently selected text
        return (0, lodash_1.get)((0, lodash_1.find)(options, { value: selected }), 'label');
    }
    getSelectedIcon() {
        const { options, selectedIcon } = this.props;
        const { selected } = this.state;
        if (selectedIcon) {
            return selectedIcon;
        }
        // return currently selected icon
        return (0, lodash_1.get)((0, lodash_1.find)(options, { value: selected }), 'icon');
    }
    getSelectedSecondaryIcon() {
        const { options, selectedSecondaryIcon } = this.props;
        const { selected } = this.state;
        if (selectedSecondaryIcon) {
            return selectedSecondaryIcon;
        }
        return (0, lodash_1.get)((0, lodash_1.find)(options, { value: selected }), 'secondaryIcon');
    }
    dropdownOptions() {
        let refIndex = 0;
        if (this.props.children) {
            // add refs and focus-on-click handlers to children
            return react_1.Children.map(this.props.children, (child) => {
                if (!child ||
                    ![item_1.default, separator_1.default, label_1.default].includes(child.type)) {
                    return null;
                }
                return (0, react_1.cloneElement)(child, {
                    ref: child.type === item_1.default ? this.setItemRef(refIndex++) : null,
                    onClick: (event) => {
                        this.dropdownContainerRef.current.focus();
                        if (typeof child.props.onClick === 'function') {
                            child.props.onClick(event);
                        }
                    },
                });
            });
        }
        return this.props.options
            .filter((item) => {
            if (this.props.showSelectedOption) {
                return true;
            }
            return item.value !== this.state.selected;
        })
            .map((item, index) => {
            if (!item) {
                return (0, jsx_runtime_1.jsx)(separator_1.default, {}, 'dropdown-separator-' + index);
            }
            if (item.isLabel) {
                return (0, jsx_runtime_1.jsx)(label_1.default, { children: item.label }, 'dropdown-label-' + index);
            }
            return ((0, jsx_runtime_1.jsx)(item_1.default, { ref: this.setItemRef(refIndex++), selected: this.state.selected === item.value, onClick: this.onSelectItem(item), path: item.path, icon: item.icon, secondaryIcon: item.secondaryIcon, count: item.count, children: item.label }, 'dropdown-item-' + item.value));
        });
    }
    render() {
        const dropdownClassName = (0, clsx_1.default)('select-dropdown', this.props.className, {
            'is-compact': this.props.compact,
            'is-open': this.state.isOpen && !this.props.disabled,
            'is-disabled': this.props.disabled,
            'has-count': 'number' === typeof this.props.selectedCount,
            'is-loading': this.props?.isLoading,
        });
        const selectedText = this.getSelectedText();
        const selectedIcon = this.getSelectedIcon();
        const selectedSecondaryIcon = this.getSelectedSecondaryIcon();
        const { positionSelectedSecondaryIconOnRight } = this.props;
        return ((0, jsx_runtime_1.jsx)("div", { id: this.props.id, style: this.props.style, className: dropdownClassName, children: (0, jsx_runtime_1.jsxs)("div", { ref: this.dropdownContainerRef, className: "select-dropdown__container", onKeyDown: this.navigateItem, tabIndex: this.props.tabIndex || 0, role: "button", "aria-haspopup": "true", "aria-owns": 'select-submenu-' + this.instanceId, "aria-controls": 'select-submenu-' + this.instanceId, "aria-expanded": this.state.isOpen, "aria-disabled": this.props.disabled, "data-tip-target": this.props.tipTarget, onClick: this.toggleDropdown, children: [(0, jsx_runtime_1.jsxs)("div", { id: 'select-dropdown-' + this.instanceId, className: "select-dropdown__header", children: [(0, jsx_runtime_1.jsxs)("span", { className: "select-dropdown__header-text", "aria-label": this.props.ariaLabel, children: [!positionSelectedSecondaryIconOnRight && selectedSecondaryIcon, selectedIcon, selectedText] }), 'number' === typeof this.props.selectedCount && ((0, jsx_runtime_1.jsx)(count_1.default, { count: this.props.selectedCount })), positionSelectedSecondaryIconOnRight && selectedSecondaryIcon, (0, jsx_runtime_1.jsx)(gridicon_1.default, { icon: "chevron-down", size: 18 })] }), (0, jsx_runtime_1.jsx)("ul", { id: 'select-submenu-' + this.instanceId, className: "select-dropdown__options", role: "listbox", "aria-labelledby": 'select-dropdown-' + this.instanceId, "aria-expanded": this.state.isOpen, children: this.dropdownOptions() })] }) }));
    }
    toggleDropdown = () => {
        if (this.props && this.props.disabled) {
            return;
        }
        this.setState({
            isOpen: !this.state.isOpen,
        });
    };
    openDropdown() {
        if (this.props && this.props.disabled) {
            return;
        }
        this.setState({
            isOpen: true,
        });
    }
    closeDropdown() {
        if (this.state.isOpen) {
            delete this.focused;
            this.setState({
                isOpen: false,
            });
        }
    }
    onSelectItem(option) {
        return this.selectItem.bind(this, option);
    }
    selectItem(option) {
        if (!option) {
            return;
        }
        if (this.props.onSelect) {
            this.props.onSelect(option);
        }
        this.setState({
            selected: option.value,
        });
        this.dropdownContainerRef.current.focus();
    }
    navigateItem = (event) => {
        switch (event.code) {
            case 'Tab':
                this.navigateItemByTabKey(event);
                break;
            case 'Space':
            case 'Enter':
                event.preventDefault();
                this.activateItem();
                break;
            case 'ArrowUp':
                event.preventDefault();
                this.focusSibling('previous');
                this.openDropdown();
                break;
            case 'ArrowDown':
                event.preventDefault();
                this.focusSibling('next');
                this.openDropdown();
                break;
            case 'Escape':
                event.preventDefault();
                this.closeDropdown();
                this.dropdownContainerRef.current.focus();
                break;
        }
    };
    navigateItemByTabKey(event) {
        if (!this.state.isOpen) {
            return;
        }
        event.preventDefault();
        const direction = event.shiftKey ? 'previous' : 'next';
        this.focusSibling(direction);
    }
    activateItem() {
        if (!this.state.isOpen) {
            return this.openDropdown();
        }
        document.activeElement.click();
    }
    focusSibling(direction) {
        // the initial up-arrow/down-arrow should only open the menu
        if (!this.state.isOpen) {
            return;
        }
        let items;
        let focusedIndex;
        if (this.props.options.length) {
            items = (0, lodash_1.filter)(this.props.options, (item) => {
                if (!item || item.isLabel) {
                    return false;
                }
                if (!this.props.showSelectedOption && item.value === this.state.selected) {
                    return false;
                }
                return true;
            });
            focusedIndex =
                typeof this.focused === 'number'
                    ? this.focused
                    : items.findIndex((item) => item.value === this.state.selected);
        }
        else {
            items = (0, lodash_1.filter)(this.props.children, (item) => item.type === item_1.default);
            focusedIndex =
                typeof this.focused === 'number'
                    ? this.focused
                    : items.findIndex((item) => item.props.selected);
        }
        const increment = direction === 'previous' ? -1 : 1;
        const newIndex = focusedIndex + increment;
        if (newIndex >= items.length || newIndex < 0) {
            return;
        }
        this.itemRefs[newIndex].focusLink();
        this.focused = newIndex;
    }
    handleOutsideClick = (event) => {
        if (!this.dropdownContainerRef.current.contains(event.target)) {
            this.closeDropdown();
        }
    };
}
exports.default = SelectDropdown;
exports.SelectDropdownForwardingRef = (0, react_1.forwardRef)((props, ref) => ((0, jsx_runtime_1.jsx)(SelectDropdown, { ...props, innerRef: ref })));
//# sourceMappingURL=index.js.map