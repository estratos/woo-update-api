"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.retrieveLocaleFromPathLocaleInFront = exports.removeLocaleFromPathLocaleInFront = exports.addLocaleToPathLocaleInFront = exports.isTranslatedIncompletely = exports.isMagnificentLocale = exports.filterLanguageRevisions = exports.removeLocaleFromPath = exports.addLocaleToPath = exports.getLocaleFromPath = exports.getLanguage = exports.getAnyLanguageRouteParam = exports.getLanguageRouteParam = exports.getMappedLanguageSlug = exports.getLanguageSlugs = exports.translationExists = exports.canBeTranslated = exports.isLocaleRtl = exports.isLocaleVariant = exports.isDefaultLocale = exports.getPathParts = exports.localeRegexString = void 0;
const tslib_1 = require("tslib");
const calypso_config_1 = tslib_1.__importDefault(require("@automattic/calypso-config"));
const calypso_url_1 = require("@automattic/calypso-url");
const languages_1 = tslib_1.__importDefault(require("@automattic/languages"));
const i18n_1 = require("@wordpress/i18n");
const lodash_1 = require("lodash");
const locale_context_1 = require("./locale-context");
/**
 * This regex is defined as a string so that it can be combined with other regexes.
 *
 * a locale can consist of three component
 * aa: language code
 * -bb: regional code
 * _cc: variant suffix
 * while the language code is mandatory, the other two are optional.
 */
exports.localeRegexString = '[a-zA-Z]{2,3}(-[a-zA-Z]{2,3})?(_[a-zA-Z]{2,6})?';
const localeOnlyRegex = new RegExp('^' + exports.localeRegexString + '$');
function getPathParts(path) {
    // Remove trailing slash then split. If there is a trailing slash,
    // then the end of the array could contain an empty string.
    return path.replace(/\/$/, '').split('/');
}
exports.getPathParts = getPathParts;
/**
 * Checks if provided locale is a default one.
 * @param {string} locale - locale slug (eg: 'fr')
 * @returns {boolean} true when the default locale is provided
 */
function isDefaultLocale(locale) {
    return locale === (0, calypso_config_1.default)('i18n_default_locale_slug');
}
exports.isDefaultLocale = isDefaultLocale;
/**
 * Checks if provided locale has a parentLangSlug and is therefore a locale variant
 * @param {string} locale - locale slug (eg: 'fr')
 * @returns {boolean} true when the locale has a parentLangSlug
 */
function isLocaleVariant(locale) {
    if (typeof locale !== 'string') {
        return false;
    }
    const language = getLanguage(locale);
    return !!language && typeof language.parentLangSlug === 'string';
}
exports.isLocaleVariant = isLocaleVariant;
function isLocaleRtl(locale) {
    if (typeof locale !== 'string') {
        return null;
    }
    const language = getLanguage(locale);
    if (!language) {
        return null;
    }
    return Boolean(language.rtl);
}
exports.isLocaleRtl = isLocaleRtl;
/**
 * Checks against a list of locales that don't have any GP translation sets
 * A 'translation set' refers to a collection of strings to be translated see:
 * https://glotpress.blog/the-manual/translation-sets/
 * @param {string} locale - locale slug (eg: 'fr')
 * @returns {boolean} true when the locale is NOT a member of the exception list
 */
function canBeTranslated(locale) {
    return ['en', 'sr_latin'].indexOf(locale) === -1;
}
exports.canBeTranslated = canBeTranslated;
/**
 * To be used with the same parameters as i18n-calpyso's translate():
 * Check whether the user would be exposed to text not in their language.
 *
 * Since the text is in English, this is always true in that case. Otherwise
 * We check whether a translation was provided for this text.
 * @returns {boolean} true when a user would see text they can read.
 */
function translationExists(phrase) {
    const localeSlug = (0, locale_context_1.getWpI18nLocaleSlug)() || 'en';
    return isDefaultLocale(localeSlug) || (0, i18n_1.hasTranslation)(phrase);
}
exports.translationExists = translationExists;
/**
 * Return a list of all supported language slugs
 * @returns {Array} A list of all supported language slugs
 */
function getLanguageSlugs() {
    return (0, lodash_1.map)(languages_1.default, 'langSlug');
}
exports.getLanguageSlugs = getLanguageSlugs;
/**
 * Map provided language slug to supported slug if applicable.
 * @param {string} langSlug Locale slug for the language
 * @returns {string} Mapped language slug
 */
function getMappedLanguageSlug(langSlug) {
    // See pxLjZ-6UQ-p2 for details.
    if (langSlug === 'no') {
        return 'nb';
    }
    return langSlug;
}
exports.getMappedLanguageSlug = getMappedLanguageSlug;
/**
 * Return a specifier for page.js/Express route param that enumerates all supported languages.
 * @param {string} name of the parameter. By default it's `lang`, some routes use `locale`.
 * @param {boolean} optional whether to put the `?` character at the end, making the param optional
 * @returns {string} Router param specifier that looks like `:lang(cs|de|fr|pl)`
 */
function getLanguageRouteParam(name = 'lang', optional = true) {
    return `:${name}(${getLanguageSlugs().join('|')})${optional ? '?' : ''}`;
}
exports.getLanguageRouteParam = getLanguageRouteParam;
/**
 * Return a specifier for a route param to match anything that looks like a language code, whether it is valid or not.
 * This is useful for routes that need to match any language, including unsupported ones.
 * @returns {string} Router param specifier string
 */
function getAnyLanguageRouteParam() {
    return ':lang([a-z]{2,3}|[a-z]{2}-[a-z]{2})';
}
exports.getAnyLanguageRouteParam = getAnyLanguageRouteParam;
/**
 * Matches and returns language from config.languages based on the given localeSlug
 * @param   {string} langSlug locale slug of the language to match
 * @returns {Object | undefined} An object containing the locale data or undefined.
 */
function getLanguage(langSlug) {
    langSlug = getMappedLanguageSlug(langSlug);
    if (langSlug && localeOnlyRegex.test(langSlug)) {
        // Find for the langSlug first. If we can't find it, split it and find its parent slug.
        // Please see the comment above `localeOnlyRegex` to see why we can split by - or _ and find the parent slug.
        return ((0, lodash_1.find)(languages_1.default, { langSlug }) ||
            (0, lodash_1.find)(languages_1.default, { langSlug: langSlug.split(/[-_]/)[0] }));
    }
    return undefined;
}
exports.getLanguage = getLanguage;
/**
 * Assuming that locale is adding at the end of path, retrieves the locale if present.
 * @param {string} path - original path
 * @returns {string|undefined} The locale slug if present or undefined
 */
function getLocaleFromPath(path) {
    const urlParts = (0, calypso_url_1.getUrlParts)(path);
    const locale = getPathParts(urlParts.pathname).pop();
    return 'undefined' === typeof getLanguage(locale) ? undefined : locale;
}
exports.getLocaleFromPath = getLocaleFromPath;
/**
 * Adds a locale slug to the current path.
 *
 * Will replace existing locale slug, if present.
 * @param path - original path
 * @param locale - locale slug (eg: 'fr')
 * @returns original path with new locale slug
 */
function addLocaleToPath(path, locale) {
    const urlParts = (0, calypso_url_1.getUrlParts)(path);
    const queryString = urlParts.search || '';
    return removeLocaleFromPath(urlParts.pathname) + `/${locale}` + queryString;
}
exports.addLocaleToPath = addLocaleToPath;
/**
 * Removes the trailing locale slug from the path, if it is present.
 * '/start/en' => '/start', '/start' => '/start', '/start/flow/fr' => '/start/flow', '/start/flow' => '/start/flow'
 * @param  path - original path
 * @returns original path minus locale slug
 */
function removeLocaleFromPath(path) {
    const urlParts = (0, calypso_url_1.getUrlParts)(path);
    const queryString = urlParts.search || '';
    const parts = getPathParts(urlParts.pathname);
    const locale = parts.pop();
    if ('undefined' === typeof getLanguage(locale)) {
        parts.push(locale);
    }
    return parts.join('/') + queryString;
}
exports.removeLocaleFromPath = removeLocaleFromPath;
/**
 * Filter out unexpected values from the given language revisions object.
 * @param {Object} languageRevisions A candidate language revisions object for filtering.
 * @returns {Object} A valid language revisions object derived from the given one.
 */
function filterLanguageRevisions(languageRevisions) {
    const langSlugs = getLanguageSlugs();
    // Since there is no strong guarantee that the passed-in revisions map will have the identical set of languages as we define in calypso,
    // simply filtering against what we have here should be sufficient.
    return (0, lodash_1.pickBy)(languageRevisions, (revision, slug) => {
        if (typeof revision !== 'number') {
            return false;
        }
        if (!(0, lodash_1.includes)(langSlugs, slug)) {
            return false;
        }
        return true;
    });
}
exports.filterLanguageRevisions = filterLanguageRevisions;
/**
 * Checks if provided locale is one of the magnificenet non-english locales.
 * @param locale Locale slug
 * @returns true when provided magnificent non-english locale.
 */
function isMagnificentLocale(locale) {
    return (0, calypso_config_1.default)('magnificent_non_en_locales').includes(locale);
}
exports.isMagnificentLocale = isMagnificentLocale;
/**
 * Checks if provided locale is translated incompletely (is missing essential translations).
 * @param   {string}  locale Locale slug
 * @returns {boolean} Whether provided locale is flagged as translated incompletely.
 */
function isTranslatedIncompletely(locale) {
    return getLanguage(locale)?.isTranslatedIncompletely === true;
}
exports.isTranslatedIncompletely = isTranslatedIncompletely;
/**
 * Adds a locale slug infront of the current path.
 *
 * Will replace existing locale slug, if present.
 * @param path - original path
 * @param locale - the locale to add to the path (Optional)
 * @returns original path with new locale slug
 */
function addLocaleToPathLocaleInFront(path, locale) {
    const localeOrDefault = locale || (0, locale_context_1.getWpI18nLocaleSlug)();
    const urlParts = (0, calypso_url_1.getUrlParts)(path);
    const queryString = urlParts.search || '';
    if (!localeOrDefault || isDefaultLocale(localeOrDefault)) {
        return path;
    }
    return (`/${localeOrDefault}` + removeLocaleFromPathLocaleInFront(urlParts.pathname) + queryString);
}
exports.addLocaleToPathLocaleInFront = addLocaleToPathLocaleInFront;
/**
 * Removes the locale slug in the start of the path, if it is present.
 * '/en/themes' => '/themes', '/themes' => '/themes', '/fr/plugins' => '/plugins'
 * @param  path - original path
 * @returns original path minus locale slug
 */
function removeLocaleFromPathLocaleInFront(path) {
    // Remove the first '/'.
    path = path.slice(1);
    const urlParts = (0, calypso_url_1.getUrlParts)(path);
    const queryString = urlParts.search || '';
    const parts = getPathParts(urlParts.pathname);
    const locale = parts.shift();
    if ('undefined' === typeof getLanguage(locale)) {
        parts.unshift(locale);
    }
    return '/' + parts.join('/') + queryString;
}
exports.removeLocaleFromPathLocaleInFront = removeLocaleFromPathLocaleInFront;
/**
 * Retreive the locale slug in the start of the path, if it is present.
 * '/en/themes' => 'en', '/themes' => 'en', '/fr/plugins' => 'fr'
 * @param  path - original path
 * @returns locale
 */
function retrieveLocaleFromPathLocaleInFront(path) {
    // Remove the first '/'.
    path = path.slice(1);
    const urlParts = (0, calypso_url_1.getUrlParts)(path);
    const parts = getPathParts(urlParts.pathname);
    const locale = parts.shift();
    if (locale && getLanguage(locale)) {
        return locale;
    }
    return 'en';
}
exports.retrieveLocaleFromPathLocaleInFront = retrieveLocaleFromPathLocaleInFront;
//# sourceMappingURL=utils.js.map