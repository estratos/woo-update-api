"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _element = require("@wordpress/element");

var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));

var _classnames = _interopRequireDefault(require("classnames"));

var _reactDom = require("@floating-ui/react-dom");

var _compose = require("@wordpress/compose");

var _icons = require("@wordpress/icons");

var _deprecated = _interopRequireDefault(require("@wordpress/deprecated"));

var _primitives = require("@wordpress/primitives");

var _button = _interopRequireDefault(require("../button"));

var _scrollLock = _interopRequireDefault(require("../scroll-lock"));

var _slotFill = require("../slot-fill");

var _animate = require("../animate");

// @ts-nocheck

/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */

/**
 * Name of slot in which popover should fill.
 *
 * @type {string}
 */
const SLOT_NAME = 'Popover'; // An SVG displaying a triangle facing down, filled with a solid
// color and bordered in such a way to create an arrow-like effect.
// Keeping the SVG's viewbox squared simplify the arrow positioning
// calculations.

const ArrowTriangle = props => (0, _element.createElement)(_primitives.SVG, (0, _extends2.default)({}, props, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: `0 0 100 100`,
  className: "components-popover__triangle",
  role: "presentation"
}), (0, _element.createElement)(_primitives.Path, {
  className: "components-popover__triangle-bg",
  d: "M 0 0 L 50 50 L 100 0"
}), (0, _element.createElement)(_primitives.Path, {
  className: "components-popover__triangle-border",
  d: "M 0 0 L 50 50 L 100 0",
  vectorEffect: "non-scaling-stroke"
}));

const slotNameContext = (0, _element.createContext)();

const positionToPlacement = position => {
  const [x, y, z] = position.split(' ');

  if (['top', 'bottom'].includes(x)) {
    let suffix = '';

    if (!!z && z === 'left' || y === 'right') {
      suffix = '-start';
    } else if (!!z && z === 'right' || y === 'left') {
      suffix = '-end';
    }

    return x + suffix;
  }

  return y;
};

const placementToAnimationOrigin = placement => {
  const [a, b] = placement.split('-');
  let x, y;

  if (a === 'top' || a === 'bottom') {
    x = a === 'top' ? 'bottom' : 'top';
    y = 'middle';

    if (b === 'start') {
      y = 'left';
    } else if (b === 'end') {
      y = 'right';
    }
  }

  if (a === 'left' || a === 'right') {
    x = 'center';
    y = a === 'left' ? 'right' : 'left';

    if (b === 'start') {
      x = 'top';
    } else if (b === 'end') {
      x = 'bottom';
    }
  }

  return x + ' ' + y;
};

const Popover = (_ref, forwardedRef) => {
  let {
    range,
    animate = true,
    headerTitle,
    onClose,
    children,
    className,
    noArrow = true,
    isAlternate,
    position,
    placement: placementProp = 'bottom-start',
    offset,
    focusOnMount = 'firstElement',
    anchorRef,
    anchorRect,
    getAnchorRect,
    expandOnMobile,
    onFocusOutside,
    __unstableSlotName = SLOT_NAME,
    __unstableObserveElement,
    __unstableForcePosition = false,
    __unstableShift = false,
    ...contentProps
  } = _ref;

  if (range) {
    (0, _deprecated.default)('range prop in Popover component', {
      since: '6.1',
      version: '6.3'
    });
  }

  const arrowRef = (0, _element.useRef)(null);
  const anchorRefFallback = (0, _element.useRef)(null);
  const isMobileViewport = (0, _compose.useViewportMatch)('medium', '<');
  const isExpanded = expandOnMobile && isMobileViewport;
  const hasArrow = !isExpanded && !noArrow;
  const normalizedPlacementFromProps = position ? positionToPlacement(position) : placementProp;
  const ownerDocument = (0, _element.useMemo)(() => {
    var _documentToReturn;

    let documentToReturn;

    if (anchorRef !== null && anchorRef !== void 0 && anchorRef.top) {
      documentToReturn = anchorRef === null || anchorRef === void 0 ? void 0 : anchorRef.top.ownerDocument;
    } else if (anchorRef !== null && anchorRef !== void 0 && anchorRef.startContainer) {
      documentToReturn = anchorRef.startContainer.ownerDocument;
    } else if (anchorRef !== null && anchorRef !== void 0 && anchorRef.current) {
      documentToReturn = anchorRef.current.ownerDocument;
    } else if (anchorRef) {
      // This one should be deprecated.
      documentToReturn = anchorRef.ownerDocument;
    } else if (anchorRect && anchorRect !== null && anchorRect !== void 0 && anchorRect.ownerDocument) {
      documentToReturn = anchorRect.ownerDocument;
    } else if (getAnchorRect) {
      var _getAnchorRect;

      documentToReturn = (_getAnchorRect = getAnchorRect(anchorRefFallback.current)) === null || _getAnchorRect === void 0 ? void 0 : _getAnchorRect.ownerDocument;
    }

    return (_documentToReturn = documentToReturn) !== null && _documentToReturn !== void 0 ? _documentToReturn : document;
  }, [anchorRef, anchorRect, getAnchorRect]);
  /**
   * Offsets the position of the popover when the anchor is inside an iframe.
   */

  const frameOffset = (0, _element.useMemo)(() => {
    const {
      defaultView
    } = ownerDocument;
    const {
      frameElement
    } = defaultView;

    if (!frameElement || ownerDocument === document) {
      return undefined;
    }

    const iframeRect = frameElement.getBoundingClientRect();
    return {
      x: iframeRect.left,
      y: iframeRect.top
    };
  }, [ownerDocument]);
  const middleware = [frameOffset || offset ? (0, _reactDom.offset)(_ref2 => {
    let {
      placement: currentPlacement
    } = _ref2;

    if (!frameOffset) {
      return offset;
    }

    const isTopBottomPlacement = currentPlacement.includes('top') || currentPlacement.includes('bottom'); // The main axis should represent the gap between the
    // floating element and the reference element. The cross
    // axis is always perpendicular to the main axis.

    const mainAxis = isTopBottomPlacement ? 'y' : 'x';
    const crossAxis = mainAxis === 'x' ? 'y' : 'x'; // When the popover is before the reference, subtract the offset,
    // of the main axis else add it.

    const hasBeforePlacement = currentPlacement.includes('top') || currentPlacement.includes('left');
    const mainAxisModifier = hasBeforePlacement ? -1 : 1;
    const normalizedOffset = offset ? offset : 0;
    return {
      mainAxis: normalizedOffset + frameOffset[mainAxis] * mainAxisModifier,
      crossAxis: frameOffset[crossAxis]
    };
  }) : undefined, __unstableForcePosition ? undefined : (0, _reactDom.flip)(), __unstableForcePosition ? undefined : (0, _reactDom.size)({
    apply(sizeProps) {
      const {
        height
      } = sizeProps;
      if (!refs.floating.current) return; // Reduce the height of the popover to the available space.

      Object.assign(refs.floating.current.firstChild.style, {
        maxHeight: `${height}px`,
        overflow: 'auto'
      });
    }

  }), __unstableShift ? (0, _reactDom.shift)({
    crossAxis: true,
    limiter: (0, _reactDom.limitShift)(),
    padding: 1 // Necessary to avoid flickering at the edge of the viewport.

  }) : undefined, hasArrow ? (0, _reactDom.arrow)({
    element: arrowRef
  }) : undefined].filter(m => !!m);

  const slotName = (0, _element.useContext)(slotNameContext) || __unstableSlotName;

  const slot = (0, _slotFill.useSlot)(slotName);
  let onDialogClose;

  if (onClose || onFocusOutside) {
    onDialogClose = (type, event) => {
      // Ideally the popover should have just a single onClose prop and
      // not three props that potentially do the same thing.
      if (type === 'focus-outside' && onFocusOutside) {
        onFocusOutside(event);
      } else if (onClose) {
        onClose();
      }
    };
  }

  const [dialogRef, dialogProps] = (0, _compose.__experimentalUseDialog)({
    focusOnMount,
    __unstableOnClose: onDialogClose,
    onClose: onDialogClose
  });
  const {
    // Positioning coordinates
    x,
    y,
    // Callback refs (not regular refs). This allows the position to be updated.
    // when either elements change.
    reference,
    floating,
    // Object with "regular" refs to both "reference" and "floating"
    refs,
    // Type of CSS position property to use (absolute or fixed)
    strategy,
    update,
    placement: computedPlacement,
    middlewareData: {
      arrow: arrowData = {}
    }
  } = (0, _reactDom.useFloating)({
    placement: normalizedPlacementFromProps,
    middleware
  }); // Update the `reference`'s ref.
  //
  // In floating-ui's terms:
  // - "reference" refers to the popover's anchor element.
  // - "floating" refers the floating popover's element.
  // A floating element can also be positioned relative to a virtual element,
  // instead of a real one. A virtual element is represented by an object
  // with the `getBoundingClientRect()` function (like real elements).
  // See https://floating-ui.com/docs/virtual-elements for more info.

  (0, _element.useLayoutEffect)(() => {
    let resultingReferenceRef;

    if (anchorRef !== null && anchorRef !== void 0 && anchorRef.top) {
      // Create a virtual element for the ref. The expectation is that
      // if anchorRef.top is defined, then anchorRef.bottom is defined too.
      resultingReferenceRef = {
        getBoundingClientRect() {
          const topRect = anchorRef.top.getBoundingClientRect();
          const bottomRect = anchorRef.bottom.getBoundingClientRect();
          return new window.DOMRect(topRect.x, topRect.y, topRect.width, bottomRect.bottom - topRect.top);
        }

      };
    } else if (anchorRef !== null && anchorRef !== void 0 && anchorRef.current) {
      // Standard React ref.
      resultingReferenceRef = anchorRef.current;
    } else if (anchorRef) {
      // If `anchorRef` holds directly the element's value (no `current` key)
      // This is a weird scenario and should be deprecated.
      resultingReferenceRef = anchorRef;
    } else if (anchorRect) {
      // Create a virtual element for the ref.
      resultingReferenceRef = {
        getBoundingClientRect() {
          return anchorRect;
        }

      };
    } else if (getAnchorRect) {
      // Create a virtual element for the ref.
      resultingReferenceRef = {
        getBoundingClientRect() {
          var _rect$x, _rect$y, _rect$width, _rect$height;

          const rect = getAnchorRect(anchorRefFallback.current);
          return new window.DOMRect((_rect$x = rect.x) !== null && _rect$x !== void 0 ? _rect$x : rect.left, (_rect$y = rect.y) !== null && _rect$y !== void 0 ? _rect$y : rect.top, (_rect$width = rect.width) !== null && _rect$width !== void 0 ? _rect$width : rect.right - rect.left, (_rect$height = rect.height) !== null && _rect$height !== void 0 ? _rect$height : rect.bottom - rect.top);
        }

      };
    } else if (anchorRefFallback.current) {
      // If no explicit ref is passed via props, fall back to
      // anchoring to the popover's parent node.
      resultingReferenceRef = anchorRefFallback.current.parentNode;
    }

    if (!resultingReferenceRef) {
      return;
    }

    reference(resultingReferenceRef);

    if (!refs.floating.current) {
      return;
    }

    return (0, _reactDom.autoUpdate)(resultingReferenceRef, refs.floating.current, update);
  }, [anchorRef, anchorRect, getAnchorRect]); // This is only needed for a smooth transition when moving blocks.

  (0, _element.useLayoutEffect)(() => {
    if (!__unstableObserveElement) {
      return;
    }

    const observer = new window.MutationObserver(update);
    observer.observe(__unstableObserveElement, {
      attributes: true
    });
    return () => {
      observer.disconnect();
    };
  }, [__unstableObserveElement]); // If the reference element is in a different ownerDocument (e.g. iFrame),
  // we need to manually update the floating's position as the reference's owner
  // document scrolls.

  (0, _element.useLayoutEffect)(() => {
    if (ownerDocument === document) {
      return;
    }

    ownerDocument.addEventListener('scroll', update);
    return () => ownerDocument.removeEventListener('scroll', update);
  }, [ownerDocument]);
  /** @type {false | string} */

  const animateClassName = !!animate && (0, _animate.getAnimateClassName)({
    type: 'appear',
    origin: placementToAnimationOrigin(computedPlacement)
  });
  const mergedFloatingRef = (0, _compose.useMergeRefs)([floating, dialogRef, forwardedRef]); // Disable reason: We care to capture the _bubbled_ events from inputs
  // within popover as inferring close intent.

  let content = // eslint-disable-next-line jsx-a11y/no-noninteractive-element-interactions
  // eslint-disable-next-line jsx-a11y/no-static-element-interactions
  (0, _element.createElement)("div", (0, _extends2.default)({
    className: (0, _classnames.default)('components-popover', className, animateClassName, {
      'is-expanded': isExpanded,
      'is-alternate': isAlternate
    })
  }, contentProps, {
    ref: mergedFloatingRef
  }, dialogProps, {
    tabIndex: "-1",
    style: isExpanded ? undefined : {
      position: strategy,
      left: Number.isNaN(x) ? 0 : x,
      top: Number.isNaN(y) ? 0 : y
    }
  }), isExpanded && (0, _element.createElement)(_scrollLock.default, null), isExpanded && (0, _element.createElement)("div", {
    className: "components-popover__header"
  }, (0, _element.createElement)("span", {
    className: "components-popover__header-title"
  }, headerTitle), (0, _element.createElement)(_button.default, {
    className: "components-popover__close",
    icon: _icons.close,
    onClick: onClose
  })), (0, _element.createElement)("div", {
    className: "components-popover__content"
  }, children), hasArrow && (0, _element.createElement)("div", {
    ref: arrowRef,
    className: ['components-popover__arrow', `is-${computedPlacement.split('-')[0]}`].join(' '),
    style: {
      left: Number.isFinite(arrowData === null || arrowData === void 0 ? void 0 : arrowData.x) ? `${arrowData.x}px` : '',
      top: Number.isFinite(arrowData === null || arrowData === void 0 ? void 0 : arrowData.y) ? `${arrowData.y}px` : ''
    }
  }, (0, _element.createElement)(ArrowTriangle, null)));

  if (slot.ref) {
    content = (0, _element.createElement)(_slotFill.Fill, {
      name: slotName
    }, content);
  }

  if (anchorRef || anchorRect) {
    return content;
  }

  return (0, _element.createElement)("span", {
    ref: anchorRefFallback
  }, content);
};

const PopoverContainer = (0, _element.forwardRef)(Popover);

function PopoverSlot(_ref3, ref) {
  let {
    name = SLOT_NAME
  } = _ref3;
  return (0, _element.createElement)(_slotFill.Slot, {
    bubblesVirtually: true,
    name: name,
    className: "popover-slot",
    ref: ref
  });
}

PopoverContainer.Slot = (0, _element.forwardRef)(PopoverSlot);
PopoverContainer.__unstableSlotNameProvider = slotNameContext.Provider;
var _default = PopoverContainer;
exports.default = _default;
//# sourceMappingURL=index.js.map